<!DOCTYPE html>
<html>
  <head>
    <title>Mocha Tests</title>
    <link rel="stylesheet" href="../node_modules/mocha/mocha.css">
  </head>
  <body>
    <div id="mocha"></div>
    <script src="../node_modules/mocha/mocha.js"></script>
    <script src="../node_modules/should/should.js"></script>

    <script>mocha.setup('bdd')</script>

    <!-- Load library packaged by webpack -->
    <script src="../jstreemap.js"></script>

    <!-- TreeSet tests -->
    <script>
      describe('TreeSet tests', function() {

it('constructor;', function(done) {
    let set = new TreeSet();
    should.equal(0, set.size);

    done();
});

it('constructor; array literal', function(done) {
    let set = new TreeSet([1, 2, 3]);
    should.equal(3, set.size);

    let actual = [];
    for (let k of set) {
        actual.push(k);
    }

    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; ES6 set', function(done) {
    let jsSet = new Set([2, 1, 3]);
    let set = new TreeSet(jsSet);
    should.equal(3, set.size);

    let actual = [];
    for (let k of set) {
        actual.push(k);
    }

    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; generator function', function(done) {
    let gen = function*() {
        for (let i = 1; i < 4; ++i) {
            yield i;
        }
    };
    let set = new TreeSet(gen());
    should.equal(3, set.size);

    let actual = [];
    for (let k of set) {
        actual.push(k);
    }

    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('compareFunc', function(done) {
    /* Test ability to compare alphanumeric structures like ['A',123]
       First string portion is compared. If string portions of two objects are equal then numeric portions are compared */
    class Id {
        constructor(a, n) {
            this.alpha = a;
            this.num = n;
        }
    }

    function compareIds(idLhs, idRhs) {
        if (idLhs.alpha < idRhs.alpha) {
            return -1;
        }
        else if (idLhs.alpha > idRhs.alpha) {
            return 1;
        }
        else {
            if (idLhs.num < idRhs.num) {
                return -1;
            }
            else if (idLhs.num > idRhs.num) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }

    let set = new TreeSet();
    set.compareFunc = compareIds;
    set.add(new Id('B', 8));
    set.add(new Id('A', 340));
    set.add(new Id('A', 12));
    set.add({alpha: 'AA', num: 147}); // create an ad-hoc object

    let actual = [];
    for (let k of set) {
        actual.push([k.alpha, k.num]);
    }
    let expected = [['A', 12], ['A', 340], ['AA', 147], ['B', 8]];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; invalid literal', function(done) {
    try {
        let set = new TreeSet(35);
        assert(false, 'The error was not detected');
    }
    catch (err) {
        let msg = err.message;
        should.ok(msg.includes('iterable objects'), msg);
    }
    done();
});

it('constructor; null', function(done) {
    let set = new TreeSet(null);
    should.equal(0, set.size);

    done();
});

it('constructor; null', function(done) {
    let set = new TreeSet(undefined);
    should.equal(0, set.size);

    done();
});

it('toStringTag', function(done) {
    let expected = '[object TreeSet]';
    let actual = Object.prototype.toString.call(new TreeSet());
    should.strictEqual(expected, actual);

    done();
});

it('species; on object', function(done) {
    let set = new TreeSet();
    let constrFunc = Object.getPrototypeOf(set).constructor[Symbol.species];
    let set2 = new constrFunc();
    should.ok(set2 instanceof TreeSet);

    done();
});

it('species; on class', function(done) {
    let ctr = TreeSet[Symbol.species];
    let actual = new ctr();
    should.ok(actual instanceof TreeSet);

    done();
});

it('clear', function(done) {
    let set = new TreeSet([1, 2, 3]);
    set.clear();
    should.equal(0, set.size);

    done();
});

it('delete', function(done) {
    let set = new TreeSet([1, 2, 3]);
    set.delete(2);
    let expected = '{1,3}';
    should.equal(expected, set.toString());
    set.delete(4);
    should.equal(expected, set.toString());

    done();
});

it('entries', function(done) {
    let set = new TreeSet([1, 2, 3]);
    let actual = [];
    for (let key of set.entries()) {
        actual.push(key);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('forEach', function(done) {
    let set = new TreeSet([1, 2, 3]);
    let actual = [];
    set.forEach(function(value, key, container) {
        actual.push([key, value]);
    });
    let expected = [[1, 1], [2, 2], [3, 3]];
    should.deepEqual(expected, actual);

    done();
});

it('has', function(done) {
    let set = new TreeSet([1, 2, 3]);
    should.equal(true, set.has(1));
    should.equal(false, set.has(4));

    done();
});

it('keys', function(done) {
    let set = new TreeSet([1, 2, 3]);
    let actual = [];
    for (let key of set.keys()) {
        actual.push(key);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('values', function(done) {
    let set = new TreeSet([1, 2, 3]);
    let actual = [];
    for (let value of set.values()) {
        actual.push(value);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('backward', function(done) {
    let set = new TreeSet([1, 2, 3]);
    let actual = [];
    for (let key of set.backward()) {
        actual.push(key);
    }
    let expected = [3, 2, 1];
    should.deepEqual(expected, actual);

    done();
});

it('begin/end', function(done) {
    let set = new TreeSet([1, 2, 3]);
    let actual = [];
    for (let it = set.begin(); !it.equals(set.end()); it.next()) {
        actual.push(it.key);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('rbegin/rend', function(done) {
    let set = new TreeSet([1, 2, 3]);
    let actual = [];
    for (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {
        actual.push(it.key);
    }
    let expected = [3, 2, 1];
    should.deepEqual(expected, actual);

    done();
});

it('find', function(done) {
    let set = new TreeSet([1, 2, 3]);
    let it = set.find(2);
    should.equal(2, it.key);

    it = set.find(4);
    should.ok(it.equals(set.end()));

    done();
});

it('lowerBound / upperBound', function(done) {
    let set = new TreeSet();
    for (let i = 1; i <= 16; ++i) {
        set.add(i * 2, `N${i}`);
    }
    let actual = [];
    let from = set.lowerBound(0);
    let to = set.upperBound(50);
    let it = to;
    while (!it.equals(from)) {
        it.prev();
        actual.push(it.key);
    }
    let expected = [32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2];
    should.deepEqual(expected, actual);

    done();
});

it('insertUnique', function(done) {
    let set = new TreeSet();
    for (let i = 1; i < 4; ++i) {
        let res = set.insertUnique(1);
        if (i === 1) {
            should.ok(res.wasAdded);
            should.ok(!res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
        }
        else {
            should.ok(!res.wasAdded);
            should.ok(!res.wasReplaced);
        }
    }
    should.equal(1, set.size);

    done();
});

it('insertOrUpdate', function(done) {
    let set = new TreeSet();
    for (let i = 1; i < 4; ++i) {
        let res = set.insertOrReplace(1);
        if (i === 1) {
            should.ok(res.wasAdded);
            should.ok(!res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
        }
        else {
            should.ok(!res.wasAdded);
            should.ok(res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
        }
    }
    should.equal(1, set.size);

    done();
});

it('erase', function(done) {
    let map = new TreeSet([1, 2, 3]);
    let it = map.find(2);
    it.prev();
    map.erase(it);
    let expected = '{2,3}';
    should.equal(expected, map.toString());
    map.delete(4);
    should.equal(expected, map.toString());

    done();
});

});
    </script>

    <!-- TreeMap tests -->
    <script>
      describe('TreeMap tests', function() {

it('constructor;', function(done) {
    let m = new TreeMap();
    should.equal(0, m.size);

    done();
});

it('constructor; array literal', function(done) {
    let m = new TreeMap([[2, 'B'], [1, 'A'], [3, 'C']]);
    should.equal(3, m.size);

    let actual = [];
    for (let [k, v] of m) {
        actual.push([k, v]);
    }

    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; ES6 map', function(done) {
    let jsMap = new Map([[2, 'B'], [1, 'A'], [3, 'C']]);
    let m = new TreeMap(jsMap);
    should.equal(3, m.size);

    let actual = [];
    for (let [k, v] of m) {
        actual.push([k, v]);
    }

    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; generator function', function(done) {
    let gen = function*() {
        for (let i = 1; i < 4; ++i) {
            yield [i, `N${i * 2}`];
        }
    };
    let m = new TreeMap(gen());
    should.equal(3, m.size);

    let actual = [];
    for (let [k, v] of m) {
        actual.push([k, v]);
    }

    let expected = [[1, 'N2'], [2, 'N4'], [3, 'N6']];
    should.deepEqual(expected, actual);

    done();
});

it('compareFunc', function(done) {
    /* Test ability to compare alphanumeric structures like ['A',123]
       First string portion is compared. If string portions of two objects are equal then numeric portions are compared */
    class Id {
        constructor(a, n) {
            this.alpha = a;
            this.num = n;
        }
    }

    function compareIds(idLhs, idRhs) {
        if (idLhs.alpha < idRhs.alpha) {
            return -1;
        }
        else if (idLhs.alpha > idRhs.alpha) {
            return 1;
        }
        else {
            if (idLhs.num < idRhs.num) {
                return -1;
            }
            else if (idLhs.num > idRhs.num) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }

    let m = new TreeMap();
    m.compareFunc = compareIds;
    m.set(new Id('B', 8), 'Book with id B8');
    m.set(new Id('A', 340), 'Book with id A340');
    m.set(new Id('A', 12), 'Book with id A12');
    m.set({alpha: 'AA', num: 147}, 'Book with id AA147'); // create an ad-hoc object

    let actual = [];
    for (let [k, v] of m) {
        actual.push([k.alpha, k.num, v]);
    }
    let expected = [
        ['A', 12, 'Book with id A12'],
        ['A', 340, 'Book with id A340'],
        ['AA', 147, 'Book with id AA147'],
        ['B', 8, 'Book with id B8']
    ];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; invalid literal', function(done) {
    try {
        let m = new TreeMap(35);
        assert(false, 'The error was not detected');
    }
    catch (err) {
        let msg = err.message;
        should.ok(msg.includes('iterable objects'), msg);
    }
    done();
});

it('constructor; null', function(done) {
    let m = new TreeMap(null);
    should.equal(0, m.size);

    done();
});

it('constructor; null', function(done) {
    let m = new TreeMap(undefined);
    should.equal(0, m.size);

    done();
});

it('toStringTag', function(done) {
    let expected = '[object TreeMap]';
    let actual = Object.prototype.toString.call(new TreeMap());
    should.strictEqual(expected, actual);

    done();
});

it('species; on object', function(done) {
    let map = new TreeMap();
    let constrFunc = Object.getPrototypeOf(map).constructor[Symbol.species];
    let map2 = new constrFunc();
    should.ok(map2 instanceof TreeMap);

    done();
});

it('species; on class', function(done) {
    let ctr = TreeMap[Symbol.species];
    let actual = new ctr();
    should.ok(actual instanceof TreeMap);

    done();
});

it('clear', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    map.clear();
    should.equal(0, map.size);

    done();
});

it('delete', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    map.delete(2);
    let expected = '{1:A,3:C}';
    should.equal(expected, map.toString());
    map.delete(4);
    should.equal(expected, map.toString());

    done();
});

it('entries', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let [key, value] of map.entries()) {
        actual.push([key, value]);
    }
    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('forEach', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    map.forEach(function(value, key, container) {
        actual.push([key, value]);
    });
    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('get', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    should.equal('A', map.get(1));
    should.equal(undefined, map.get(4));

    done();
});

it('has', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    should.equal(true, map.has(1));
    should.equal(false, map.has(4));

    done();
});

it('keys', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let key of map.keys()) {
        actual.push(key);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('values', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let value of map.values()) {
        actual.push(value);
    }
    let expected = ['A', 'B', 'C'];
    should.deepEqual(expected, actual);

    done();
});

it('backward', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let [key, value] of map.backward()) {
        actual.push([key, value]);
    }
    let expected = [[3, 'C'], [2, 'B'], [1, 'A']];
    should.deepEqual(expected, actual);

    done();
});

it('begin/end', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let it = map.begin(); !it.equals(map.end()); it.next()) {
        actual.push([it.key, it.value]);
    }
    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('rbegin/rend', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let it = map.rbegin(); !it.equals(map.rend()); it.next()) {
        actual.push([it.key, it.value]);
    }
    let expected = [[3, 'C'], [2, 'B'], [1, 'A']];
    should.deepEqual(expected, actual);

    done();
});

it('find', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let it = map.find(2);
    should.equal(2, it.key);
    should.equal('B', it.value);

    it = map.find(4);
    should.ok(it.equals(map.end()));

    done();
});

it('lowerBound / upperBound', function(done) {
    let map = new TreeMap();
    for (let i = 1; i <= 16; ++i) {
        map.set(i * 2, `N${i}`);
    }
    let actual = [];
    let from = map.lowerBound(0);
    let to = map.upperBound(50);
    let it = to;
    while (!it.equals(from)) {
        it.prev();
        actual.push(it.key);
    }
    let expected = [32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2];
    should.deepEqual(expected, actual);

    done();
});

it('insertUnique', function(done) {
    let m = new TreeMap();
    for (let i = 1; i < 4; ++i) {
        let res = m.insertUnique(1, `N${i}`);
        if (i === 1) {
            should.ok(res.wasAdded);
            should.ok(!res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
            should.strictEqual('N1', res.iterator.value);
        }
        else {
            should.ok(!res.wasAdded);
            should.ok(!res.wasReplaced);
        }
    }
    should.equal(1, m.size);

    done();
});

it('insertOrUpdate', function(done) {
    let m = new TreeMap();
    for (let i = 1; i < 4; ++i) {
        let res = m.insertOrReplace(1, `N${i}`);
        if (i === 1) {
            should.ok(res.wasAdded);
            should.ok(!res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
            should.strictEqual(`N${i}`, res.iterator.value);
        }
        else {
            should.ok(!res.wasAdded);
            should.ok(res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
            should.strictEqual(`N${i}`, res.iterator.value);
        }
    }
    should.equal(1, m.size);

    done();
});

it('erase', function(done) {
    let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let it = map.find(2);
    it.prev();
    map.erase(it);
    let expected = '{2:B,3:C}';
    should.equal(expected, map.toString());
    map.delete(4);
    should.equal(expected, map.toString());

    done();
});

});
    </script>

    <!-- TreeMultiSet tests -->
    <script>
      describe('TreeMultiSet tests', function() {

it('constructor;', function(done) {
    let m = new TreeMultiSet();
    should.equal(0, m.size);

    done();
});

it('constructor; array literal', function(done) {
    let m = new TreeMultiSet([1, 2, 3, 1]);
    should.equal(4, m.size);

    let actual = [];
    for (let k of m) {
        actual.push(k);
    }

    let expected = [1, 1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; ES6 set', function(done) {
    let jsSet = new Set([2, 1, 3]);
    let m = new TreeMultiSet(jsSet);
    should.equal(3, m.size);

    let actual = [];
    for (let k of m) {
        actual.push(k);
    }

    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; generator function', function(done) {
    let gen = function*() {
        for (let i = 1; i < 4; ++i) {
            yield i;
            yield i;
        }
    };
    let m = new TreeMultiSet(gen());
    should.equal(6, m.size);

    let actual = [];
    for (let k of m) {
        actual.push(k);
    }

    let expected = [1, 1, 2, 2, 3, 3];
    should.deepEqual(expected, actual);

    done();
});

it('compareFunc', function(done) {
    /* Test ability to compare alphanumeric structures like ['A',123]
       First string portion is compared. If string portions of two objects are equal then numeric portions are compared */
    class Id {
        constructor(a, n) {
            this.alpha = a;
            this.num = n;
        }
    }

    function compareIds(idLhs, idRhs) {
        if (idLhs.alpha < idRhs.alpha) {
            return -1;
        }
        else if (idLhs.alpha > idRhs.alpha) {
            return 1;
        }
        else {
            if (idLhs.num < idRhs.num) {
                return -1;
            }
            else if (idLhs.num > idRhs.num) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }

    let m = new TreeMultiSet();
    m.compareFunc = compareIds;
    m.add(new Id('B', 8));
    m.add(new Id('A', 340));
    m.add(new Id('A', 340));
    m.add(new Id('A', 12));
    m.add({alpha: 'AA', num: 147}); // create an ad-hoc object

    let actual = [];
    for (let k of m) {
        actual.push([k.alpha, k.num]);
    }
    let expected = [['A', 12], ['A', 340], ['A', 340], ['AA', 147], ['B', 8]];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; invalid literal', function(done) {
    try {
        let m = new TreeMultiSet(35);
        assert(false, 'The error was not detected');
    }
    catch (err) {
        let msg = err.message;
        should.ok(msg.includes('iterable objects'), msg);
    }
    done();
});

it('constructor; null', function(done) {
    let m = new TreeMultiSet(null);
    should.equal(0, m.size);

    done();
});

it('constructor; null', function(done) {
    let m = new TreeMultiSet(undefined);
    should.equal(0, m.size);

    done();
});

it('toStringTag', function(done) {
    let expected = '[object TreeMultiSet]';
    let actual = Object.prototype.toString.call(new TreeMultiSet());
    should.strictEqual(expected, actual);

    done();
});

it('species; on object', function(done) {
    let set = new TreeMultiSet();
    let constrFunc = Object.getPrototypeOf(set).constructor[Symbol.species];
    let set2 = new constrFunc();
    should.ok(set2 instanceof TreeMultiSet);

    done();
});

it('species; on class', function(done) {
    let ctr = TreeMultiSet[Symbol.species];
    let actual = new ctr();
    should.ok(actual instanceof TreeMultiSet);

    done();
});

it('clear', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    set.clear();
    should.equal(0, set.size);

    done();
});

it('delete', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    set.delete(2);
    let expected = '{1,3}';
    should.equal(expected, set.toString());
    set.delete(4);
    should.equal(expected, set.toString());

    done();
});

it('entries', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    let actual = [];
    for (let key of set.entries()) {
        actual.push(key);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('forEach', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    let actual = [];
    set.forEach(function(value, key, container) {
        actual.push([key, value]);
    });
    let expected = [[1, 1], [2, 2], [3, 3]];
    should.deepEqual(expected, actual);

    done();
});

it('has', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    should.equal(true, set.has(1));
    should.equal(false, set.has(4));

    done();
});

it('keys', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    let actual = [];
    for (let key of set.keys()) {
        actual.push(key);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('values', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    let actual = [];
    for (let value of set.values()) {
        actual.push(value);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('backward', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    let actual = [];
    for (let key of set.backward()) {
        actual.push(key);
    }
    let expected = [3, 2, 1];
    should.deepEqual(expected, actual);

    done();
});

it('begin/end', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    let actual = [];
    for (let it = set.begin(); !it.equals(set.end()); it.next()) {
        actual.push(it.key);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('rbegin/rend', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    let actual = [];
    for (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {
        actual.push(it.key);
    }
    let expected = [3, 2, 1];
    should.deepEqual(expected, actual);

    done();
});

it('find', function(done) {
    let set = new TreeMultiSet([1, 2, 3]);
    let it = set.find(2);
    should.equal(2, it.key);

    it = set.find(4);
    should.ok(it.equals(set.end()));

    done();
});

it('lowerBound / upperBound', function(done) {
    let set = new TreeMultiSet();
    for (let i = 1; i <= 16; ++i) {
        set.add(i * 2, `N${i}`);
    }
    let actual = [];
    let from = set.lowerBound(0);
    let to = set.upperBound(50);
    let it = to;
    while (!it.equals(from)) {
        it.prev();
        actual.push(it.key);
    }
    let expected = [32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2];
    should.deepEqual(expected, actual);

    done();
});

it('insertUnique', function(done) {
    let set = new TreeMultiSet();
    for (let i = 1; i < 4; ++i) {
        let res = set.insertUnique(1);
        if (i === 1) {
            should.ok(res.wasAdded);
            should.ok(!res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
        }
        else {
            should.ok(!res.wasAdded);
            should.ok(!res.wasReplaced);
        }
    }
    should.equal(1, set.size);

    done();
});

it('insertOrUpdate', function(done) {
    let set = new TreeMultiSet();
    for (let i = 1; i < 4; ++i) {
        let res = set.insertOrReplace(1);
        if (i === 1) {
            should.ok(res.wasAdded);
            should.ok(!res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
        }
        else {
            should.ok(!res.wasAdded);
            should.ok(res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
        }
    }
    should.equal(1, set.size);

    done();
});

it('insertMulti', function(done) {
    let set = new TreeMultiSet();
    for (let i = 1; i < 4; ++i) {
        let res = set.insertMulti(1);
        should.ok(res.wasAdded);
        should.ok(!res.wasReplaced);
        should.strictEqual(1, res.iterator.key);
    }
    should.equal(3, set.size);

    done();
});

it('erase', function(done) {
    let map = new TreeMultiSet([1, 2, 3]);
    let it = map.find(2);
    it.prev();
    map.erase(it);
    let expected = '{2,3}';
    should.equal(expected, map.toString());
    map.delete(4);
    should.equal(expected, map.toString());

    done();
});

});
    </script>

    <!-- TreeMultiMap tests -->
    <script>
      describe('TreeMap tests', function() {

it('constructor;', function(done) {
    let m = new TreeMultiMap();
    should.equal(0, m.size);

    done();
});

it('constructor; array literal', function(done) {
    let m = new TreeMultiMap([[2, 'B'], [2, 'A'], [3, 'C']]);
    should.equal(3, m.size);

    let actual = [];
    for (let [k, v] of m) {
        actual.push([k, v]);
    }

    let expected = [[2, 'B'], [2, 'A'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; ES6 map', function(done) {
    let jsMap = new Map([[2, 'B'], [1, 'A'], [3, 'C']]);
    let m = new TreeMultiMap(jsMap);
    should.equal(3, m.size);

    let actual = [];
    for (let [k, v] of m) {
        actual.push([k, v]);
    }

    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; generator function', function(done) {
    let gen = function*() {
        for (let i = 1; i < 4; ++i) {
            yield [i, `N${i * 2}`];
        }
    };
    let m = new TreeMultiMap(gen());
    should.equal(3, m.size);

    let actual = [];
    for (let [k, v] of m) {
        actual.push([k, v]);
    }

    let expected = [[1, 'N2'], [2, 'N4'], [3, 'N6']];
    should.deepEqual(expected, actual);

    done();
});

it('compareFunc', function(done) {
    /* Test ability to compare alphanumeric structures like ['A',123]
       First string portion is compared. If string portions of two objects are equal then numeric portions are compared */
    class Id {
        constructor(a, n) {
            this.alpha = a;
            this.num = n;
        }
    }

    function compareIds(idLhs, idRhs) {
        if (idLhs.alpha < idRhs.alpha) {
            return -1;
        }
        else if (idLhs.alpha > idRhs.alpha) {
            return 1;
        }
        else {
            if (idLhs.num < idRhs.num) {
                return -1;
            }
            else if (idLhs.num > idRhs.num) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }

    let m = new TreeMultiMap();
    m.compareFunc = compareIds;
    m.set(new Id('B', 8), 'Book with id B8');
    m.set(new Id('A', 340), 'Book with id A340');
    m.set(new Id('A', 12), 'Book with id A12');
    m.set(new Id('A', 12), 'Another book with id A12');
    m.set({alpha: 'AA', num: 147}, 'Book with id AA147'); // create an ad-hoc object

    let actual = [];
    for (let [k, v] of m) {
        actual.push([k.alpha, k.num, v]);
    }
    let expected = [
        ['A', 12, 'Book with id A12'],
        ['A', 12, 'Another book with id A12'],
        ['A', 340, 'Book with id A340'],
        ['AA', 147, 'Book with id AA147'],
        ['B', 8, 'Book with id B8']
    ];
    should.deepEqual(expected, actual);

    done();
});

it('constructor; invalid literal', function(done) {
    try {
        let m = new TreeMultiMap(35);
        assert(false, 'The error was not detected');
    }
    catch (err) {
        let msg = err.message;
        should.ok(msg.includes('iterable objects'), msg);
    }
    done();
});

it('constructor; null', function(done) {
    let m = new TreeMultiMap(null);
    should.equal(0, m.size);

    done();
});

it('constructor; null', function(done) {
    let m = new TreeMultiMap(undefined);
    should.equal(0, m.size);

    done();
});

it('toStringTag', function(done) {
    let expected = '[object TreeMultiMap]';
    let actual = Object.prototype.toString.call(new TreeMultiMap());
    should.strictEqual(expected, actual);

    done();
});

it('species; on object', function(done) {
    let map = new TreeMultiMap();
    let constrFunc = Object.getPrototypeOf(map).constructor[Symbol.species];
    let map2 = new constrFunc();
    should.ok(map2 instanceof TreeMultiMap);

    done();
});

it('species; on class', function(done) {
    let ctr = TreeMultiMap[Symbol.species];
    let actual = new ctr();
    should.ok(actual instanceof TreeMultiMap);

    done();
});

it('clear', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    map.clear();
    should.equal(0, map.size);

    done();
});

it('delete', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [2, 'C'], [3, 'D']]);
    map.delete(2);
    let expected = '{1:A,2:C,3:D}';
    should.equal(expected, map.toString());
    map.delete(2);
    expected = '{1:A,3:D}';
    should.equal(expected, map.toString());
    map.delete(4);
    should.equal(expected, map.toString());

    done();
});

it('entries', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let [key, value] of map.entries()) {
        actual.push([key, value]);
    }
    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('forEach', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    map.forEach(function(value, key, container) {
        actual.push([key, value]);
    });
    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('get', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    should.equal('A', map.get(1));
    should.equal(undefined, map.get(4));

    done();
});

it('has', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    should.equal(true, map.has(1));
    should.equal(false, map.has(4));

    done();
});

it('keys', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let key of map.keys()) {
        actual.push(key);
    }
    let expected = [1, 2, 3];
    should.deepEqual(expected, actual);

    done();
});

it('values', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let value of map.values()) {
        actual.push(value);
    }
    let expected = ['A', 'B', 'C'];
    should.deepEqual(expected, actual);

    done();
});

it('backward', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let [key, value] of map.backward()) {
        actual.push([key, value]);
    }
    let expected = [[3, 'C'], [2, 'B'], [1, 'A']];
    should.deepEqual(expected, actual);

    done();
});

it('begin/end', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let it = map.begin(); !it.equals(map.end()); it.next()) {
        actual.push([it.key, it.value]);
    }
    let expected = [[1, 'A'], [2, 'B'], [3, 'C']];
    should.deepEqual(expected, actual);

    done();
});

it('rbegin/rend', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let actual = [];
    for (let it = map.rbegin(); !it.equals(map.rend()); it.next()) {
        actual.push([it.key, it.value]);
    }
    let expected = [[3, 'C'], [2, 'B'], [1, 'A']];
    should.deepEqual(expected, actual);

    done();
});

it('find', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let it = map.find(2);
    should.equal(2, it.key);
    should.equal('B', it.value);

    it = map.find(4);
    should.ok(it.equals(map.end()));

    done();
});

it('lowerBound / upperBound', function(done) {
    let map = new TreeMultiMap();
    for (let i = 1; i <= 16; ++i) {
        map.set(i * 2, `N${i}`);
    }
    let actual = [];
    let from = map.lowerBound(0);
    let to = map.upperBound(50);
    let it = to;
    while (!it.equals(from)) {
        it.prev();
        actual.push(it.key);
    }
    let expected = [32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2];
    should.deepEqual(expected, actual);

    done();
});

it('insertUnique', function(done) {
    let m = new TreeMultiMap();
    for (let i = 1; i < 4; ++i) {
        let res = m.insertUnique(1, `N${i}`);
        if (i === 1) {
            should.ok(res.wasAdded);
            should.ok(!res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
            should.strictEqual('N1', res.iterator.value);
        }
        else {
            should.ok(!res.wasAdded);
            should.ok(!res.wasReplaced);
        }
    }
    should.equal(1, m.size);

    done();
});

it('insertOrUpdate', function(done) {
    let m = new TreeMultiMap();
    for (let i = 1; i < 4; ++i) {
        let res = m.insertOrReplace(1, `N${i}`);
        if (i === 1) {
            should.ok(res.wasAdded);
            should.ok(!res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
            should.strictEqual(`N${i}`, res.iterator.value);
        }
        else {
            should.ok(!res.wasAdded);
            should.ok(res.wasReplaced);
            should.strictEqual(1, res.iterator.key);
            should.strictEqual(`N${i}`, res.iterator.value);
        }
    }
    should.equal(1, m.size);

    done();
});

it('insertMulti', function(done) {
    let m = new TreeMultiMap();
    for (let i = 1; i < 4; ++i) {
        let res = m.insertMulti(1, `N${i}`);
        should.ok(res.wasAdded);
        should.ok(!res.wasReplaced);
        should.strictEqual(1, res.iterator.key);
        should.strictEqual(`N${i}`, res.iterator.value);
    }
    should.equal(3, m.size);

    done();
});

it('erase', function(done) {
    let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);
    let it = map.find(2);
    it.prev();
    map.erase(it);
    let expected = '{2:B,3:C}';
    should.equal(expected, map.toString());
    map.delete(4);
    should.equal(expected, map.toString());

    done();
});

});
    </script>

    <!-- Iterator tests -->
    <script>
      // Nodes are replaced with integers
class ContainerStub {
    prev(n) {
        return n - 1;
    }

    next(n) {
        return n + 1;
    }
}

describe('Iterator tests', function() {

    it('constructor; node and container', function(done) {
        let c = new ContainerStub();
        let it = new Iterator(5, c);
        should.strictEqual(5, it.node);
        should.strictEqual(c, it.container);

        done();
    });

    it('constructor; copy of an Iterator', function(done) {
        let c = new ContainerStub();
        let it = new Iterator(5, c);
        let it1 = new Iterator(it);
        should.strictEqual(5, it1.node);
        should.strictEqual(c, it1.container);

        done();
    });

    it('constructor; copy of a ReverseIterator', function(done) {
        let c = new ContainerStub();
        let it = new ReverseIterator(5, c);
        let it1 = new Iterator(it);
        should.strictEqual(6, it1.node);
        should.strictEqual(c, it1.container);

        done();
    });

    it('constructor; too many paramaters', function(done) {
        try {
            let it = new Iterator('test', 'test', 'test');
            assert(false, 'Constructor should have failed');
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('provided parameters'), msg);
        }
        done();
    });

    it('constructor; invalid copy request', function(done) {
        try {
            let it = new Iterator('test');
            assert(false, 'Constructor should have failed');
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('Iterator'), msg);
            should.ok(msg.includes('String'), msg);
        }
        done();
    });

    it('next', function(done) {
        let c = new ContainerStub();
        let it = new Iterator(5, c);
        it.next();
        should.strictEqual(6, it.node);
        should.strictEqual(c, it.container);

        done();
    });

    it('prev', function(done) {
        let c = new ContainerStub();
        let it = new Iterator(5, c);
        it.prev();
        should.strictEqual(4, it.node);
        should.strictEqual(c, it.container);

        done();
    });
});

describe('ReverseIterator tests', function() {

    it('constructor; node and container', function(done) {
        let c = new ContainerStub();
        let it = new ReverseIterator(5, c);
        should.strictEqual(5, it.node);
        should.strictEqual(c, it.container);

        done();
    });

    it('constructor; copy of an ReverseIterator', function(done) {
        let c = new ContainerStub();
        let it = new ReverseIterator(5, c);
        let it1 = new ReverseIterator(it);
        should.strictEqual(5, it1.node);
        should.strictEqual(c, it1.container);

        done();
    });

    it('constructor; copy of a Iterator', function(done) {
        let c = new ContainerStub();
        let it = new Iterator(5, c);
        let it1 = new ReverseIterator(it);
        should.strictEqual(4, it1.node);
        should.strictEqual(c, it1.container);

        done();
    });

    it('constructor; too many paramaters', function(done) {
        try {
            let it = new ReverseIterator('test', 'test', 'test');
            assert(false, 'Constructor should have failed');
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('provided parameters'), msg);
        }
        done();
    });

    it('constructor; invalid copy request', function(done) {
        try {
            let it = new ReverseIterator('test');
            assert(false, 'Constructor should have failed');
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('ReverseIterator'), msg);
            should.ok(msg.includes('String'), msg);
        }
        done();
    });

    it('next', function(done) {
        let c = new ContainerStub();
        let it = new ReverseIterator(5, c);
        it.next();
        should.strictEqual(4, it.node);
        should.strictEqual(c, it.container);

        done();
    });

    it('prev', function(done) {
        let c = new ContainerStub();
        let it = new ReverseIterator(5, c);
        it.prev();
        should.strictEqual(6, it.node);
        should.strictEqual(c, it.container);

        done();
    });
});

describe('BaseIterator tests', function() {

    it('equals; same node', function(done) {
        let c = new ContainerStub();
        let it1 = new Iterator(5, c);
        let it2 = new Iterator(5, c);
        should.ok(it1.equals(it2));
        should.ok(it2.equals(it1));

        done();
    });

    it('equals; different nodes', function(done) {
        let c = new ContainerStub();
        let it1 = new Iterator(4, c);
        let it2 = new Iterator(5, c);
        should.ok(!it1.equals(it2));
        should.ok(!it2.equals(it1));

        done();
    });

    it('equals; different containers', function(done) {
        let c1 = new ContainerStub();
        let c2 = new ContainerStub();
        let it1 = new Iterator(4, c1);
        let it2 = new Iterator(5, c2);
        try {
            it1.equals(it2);
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('different containers'), msg);
        }
        try {
            it2.equals(it1);
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('different containers'), msg);
        }

        done();
    });

    it('equals; different types of iterators', function(done) {
        let c1 = new ContainerStub();
        let c2 = new ContainerStub();
        let it1 = new Iterator(4, c1);
        let it2 = new ReverseIterator(5, c2);
        try {
            it1.equals(it2);
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('Iterator'), msg);
            should.ok(msg.includes('ReverseIterator'), msg);
        }
        try {
            it2.equals(it1);
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('Iterator'), msg);
            should.ok(msg.includes('ReverseIterator'), msg);
        }

        done();
    });

    it('equals; comparison to non-iterator object', function(done) {
        let c = new ContainerStub();
        let it = new Iterator(4, c);
        try {
            it.equals('test');
        }
        catch (err) {
            let msg = err.message;
            should.ok(msg.includes('Iterator'), msg);
            should.ok(msg.includes('String'), msg);
        }

        done();
    });
});
    </script>

    <!-- JsIterator tests -->
    <script>
      class NodeIsValuePolicy {
    fetch(n) {
        return n;
    }
}

// Nodes are replaced with integers
class ContainerStub {
    constructor() {
        this.valuePolicy = new NodeIsValuePolicy();
    }

    prev(n) {
        return n - 1;
    }

    next(n) {
        return n + 1;
    }

    // Allowed range is 0..4
    jsBegin() {
        return 0;
    }

    jsEnd() {
        return 5; // one more than the last allowed value
    }

    jsRbegin() {
        return 4;
    }

    jsRend() {
        return -1; // one less than the first allowed value
    }
}

describe('JsIterator tests', function() {

    it('forward iteration', function(done) {
        let c = new ContainerStub();
        let it = new JsIterator(c);
        let actual = [];
        while (true) {
            let res = it.next();
            if (res.done) {
                break;
            }
            actual.push(res.value);
        }
        let expected = [0, 1, 2, 3, 4];
        should.deepEqual(expected, actual);

        done();
    });

    it('backward iteration', function(done) {
        let c = new ContainerStub();
        let it = new JsReverseIterator(c);
        let actual = [];
        while (true) {
            let res = it.next();
            if (res.done) {
                break;
            }
            actual.push(res.value);
        }
        let expected = [4, 3, 2, 1, 0];
        should.deepEqual(expected, actual);

        done();
    });

    it('backward iteration using forward iterator', function(done) {
        let c = new ContainerStub();
        let it = new JsIterator(c);
        let actual = [];
        for (let v of it.backwards()) {
            actual.push(v);
        }
        let expected = [4, 3, 2, 1, 0];
        should.deepEqual(expected, actual);

        done();
    });

    it('forward iteration using backward iterator', function(done) {
        let c = new ContainerStub();
        let it = new JsReverseIterator(c);
        let actual = [];
        for (let v of it.backwards()) {
            actual.push(v);
        }
        let expected = [0, 1, 2, 3, 4];
        should.deepEqual(expected, actual);

        done();
    });
});
    </script>

    <script>
      mocha.run();
    </script>
  </body>
</html>