[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/internal/policies.js",
    "content": "/**\r\n * Used by sets\r\n * @private\r\n */\r\nclass KeyOnlyPolicy {\r\n    /**\r\n     * Returns key data from the specified node\r\n     * @param {*} n\r\n     */\r\n    fetch(n) {\r\n        return n.key;\r\n    }\r\n\r\n    /**\r\n     * Copies key data from one node to another\r\n     * @param {*} dst\r\n     * @param {*} src\r\n     */\r\n    copy(dst, src) {\r\n        dst.key = src.key;\r\n    }\r\n\r\n    /**\r\n     * @returns string representation of the key\r\n     * @param {*} node\r\n     */\r\n    toString(node) {\r\n        return String(node.key);\r\n    }\r\n}\r\n\r\n/**\r\n * Used by maps\r\n * @private\r\n */\r\nclass KeyValuePolicy {\r\n    /**\r\n     * Returns key-value data from the specified node\r\n     * @param {*} n\r\n     */\r\n    fetch(n) {\r\n        return [n.key, n.value];\r\n    }\r\n\r\n    /**\r\n     * Copies key-value data from one node to another\r\n     * @param {*} dst\r\n     * @param {*} src\r\n     */\r\n    copy(dst, src) {\r\n        dst.key = src.key;\r\n        dst.value = src.value;\r\n    }\r\n\r\n    /**\r\n     * @returns string representation of key-value pair\r\n     * @param {*} node\r\n     */\r\n    toString(node) {\r\n        return String(node.key) + ':' + String(node.value);\r\n    }\r\n}\r\n\r\n/**\r\n * Used for iteration through values of a map\r\n * @private\r\n */\r\nclass ValueOnlyPolicy {\r\n    /**\r\n     * Returns data from the specified node\r\n     * @param {*} n\r\n     */\r\n    fetch(n) {\r\n        return n.value;\r\n    }\r\n\r\n    /**\r\n     * Copies value data from one node to another\r\n     * @param {*} dst\r\n     * @param {*} src\r\n     */\r\n    copy(dst, src) {\r\n        dst.value = src.value;\r\n    }\r\n\r\n    /**\r\n     * @returns string representation of node's value\r\n     * @param {*} node\r\n     */\r\n    toString(node) {\r\n        return String(node.value);\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    KeyOnlyPolicy: KeyOnlyPolicy,\r\n    ValueOnlyPolicy: ValueOnlyPolicy,\r\n    KeyValuePolicy: KeyValuePolicy\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/internal/policies.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "KeyOnlyPolicy",
    "memberof": "src/internal/policies.js",
    "static": true,
    "longname": "src/internal/policies.js~KeyOnlyPolicy",
    "access": "private",
    "export": true,
    "importPath": "jstreemap/src/internal/policies.js",
    "importStyle": "{KeyOnlyPolicy}",
    "description": "Used by sets",
    "lineNumber": 5,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "method",
    "name": "fetch",
    "memberof": "src/internal/policies.js~KeyOnlyPolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~KeyOnlyPolicy#fetch",
    "access": "public",
    "description": "Returns key data from the specified node",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "method",
    "name": "copy",
    "memberof": "src/internal/policies.js~KeyOnlyPolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~KeyOnlyPolicy#copy",
    "access": "public",
    "description": "Copies key data from one node to another",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dst",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "src",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 52,
    "kind": "method",
    "name": "toString",
    "memberof": "src/internal/policies.js~KeyOnlyPolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~KeyOnlyPolicy#toString",
    "access": "public",
    "description": "",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "string representation of the key"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "string representation of the key"
    }
  },
  {
    "__docId__": 53,
    "kind": "class",
    "name": "ValueOnlyPolicy",
    "memberof": "src/internal/policies.js",
    "static": true,
    "longname": "src/internal/policies.js~ValueOnlyPolicy",
    "access": "private",
    "export": true,
    "importPath": "jstreemap/src/internal/policies.js",
    "importStyle": "{ValueOnlyPolicy}",
    "description": "Used for iteration through values of a map",
    "lineNumber": 68,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "fetch",
    "memberof": "src/internal/policies.js~ValueOnlyPolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~ValueOnlyPolicy#fetch",
    "access": "public",
    "description": "Returns data from the specified node",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "copy",
    "memberof": "src/internal/policies.js~ValueOnlyPolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~ValueOnlyPolicy#copy",
    "access": "public",
    "description": "Copies value data from one node to another",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dst",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "src",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "toString",
    "memberof": "src/internal/policies.js~ValueOnlyPolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~ValueOnlyPolicy#toString",
    "access": "public",
    "description": "",
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "string representation of node's value"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "string representation of node's value"
    }
  },
  {
    "__docId__": 57,
    "kind": "class",
    "name": "KeyValuePolicy",
    "memberof": "src/internal/policies.js",
    "static": true,
    "longname": "src/internal/policies.js~KeyValuePolicy",
    "access": "private",
    "export": true,
    "importPath": "jstreemap/src/internal/policies.js",
    "importStyle": "{KeyValuePolicy}",
    "description": "Used by maps",
    "lineNumber": 36,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "fetch",
    "memberof": "src/internal/policies.js~KeyValuePolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~KeyValuePolicy#fetch",
    "access": "public",
    "description": "Returns key-value data from the specified node",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "copy",
    "memberof": "src/internal/policies.js~KeyValuePolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~KeyValuePolicy#copy",
    "access": "public",
    "description": "Copies key-value data from one node to another",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dst",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "src",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "toString",
    "memberof": "src/internal/policies.js~KeyValuePolicy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/policies.js~KeyValuePolicy#toString",
    "access": "public",
    "description": "",
    "lineNumber": 59,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "string representation of key-value pair"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "string representation of key-value pair"
    }
  },
  {
    "__docId__": 61,
    "kind": "file",
    "name": "src/internal/tree-node.js",
    "content": "'use strict';\r\n\r\n/**\r\n * @private\r\n */\r\nconst RED = 1;\r\n/**\r\n * @private\r\n */\r\nconst BLACK = 2;\r\n\r\n/**\r\n * @private\r\n * A node for a red-black tree\r\n */\r\nclass TreeNode {\r\n\r\n    /**\r\n     * Default constructor\r\n     */\r\n    constructor() {\r\n        /** left child */\r\n        this.left = null;\r\n        /** right child */\r\n        this.right = null;\r\n        /** parent node */\r\n        this.parent = null;\r\n        /** key object (additional 'value' data member is added in map-like classes) */\r\n        this.key = null;\r\n        /** by default new node is red */\r\n        this.color = RED;\r\n    }\r\n\r\n    /**\r\n     * @returns parent of parent\r\n     */\r\n    grandparent() {\r\n        let p = this.parent;\r\n        if (p === null) {\r\n            return null;\r\n        } // No parent means no grandparent\r\n        return p.parent;\r\n    }\r\n\r\n    /**\r\n     * @returns the other child of the same parent\r\n     */\r\n    sibling() {\r\n        let p = this.parent;\r\n        if (p === null) {\r\n            return null;\r\n        } // No parent means no sibling\r\n        if (this === p.left) {\r\n            return p.right;\r\n        }\r\n        else {\r\n            return p.left;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns another child of the grandparent\r\n     */\r\n    uncle() {\r\n        let p = this.parent;\r\n        if (p === null) {\r\n            return null;\r\n        } // No parent means no uncle\r\n        let g = p.parent;\r\n        if (g === null) {\r\n            return null;\r\n        } // No grandparent means no uncle\r\n        return p.sibling();\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    TreeNode: TreeNode,\r\n    BLACK: BLACK,\r\n    RED: RED\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/internal/tree-node.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 62,
    "kind": "class",
    "name": "TreeNode",
    "memberof": "src/internal/tree-node.js",
    "static": true,
    "longname": "src/internal/tree-node.js~TreeNode",
    "access": "private",
    "export": true,
    "importPath": "jstreemap/src/internal/tree-node.js",
    "importStyle": "{TreeNode}",
    "description": "",
    "lineNumber": 16,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 63,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#constructor",
    "access": "public",
    "description": "Default constructor",
    "lineNumber": 21
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "left",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#left",
    "access": "public",
    "description": "left child",
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "right",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#right",
    "access": "public",
    "description": "right child",
    "lineNumber": 25,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "parent",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#parent",
    "access": "public",
    "description": "parent node",
    "lineNumber": 27,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "member",
    "name": "key",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#key",
    "access": "public",
    "description": "key object (additional 'value' data member is added in map-like classes)",
    "lineNumber": 29,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "color",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#color",
    "access": "public",
    "description": "by default new node is red",
    "lineNumber": 31,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "grandparent",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#grandparent",
    "access": "public",
    "description": "",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "parent of parent"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "parent of parent"
    },
    "params": []
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "sibling",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#sibling",
    "access": "public",
    "description": "",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "the other child of the same parent"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the other child of the same parent"
    },
    "params": []
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "uncle",
    "memberof": "src/internal/tree-node.js~TreeNode",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree-node.js~TreeNode#uncle",
    "access": "public",
    "description": "",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "another child of the grandparent"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "another child of the grandparent"
    },
    "params": []
  },
  {
    "__docId__": 72,
    "kind": "variable",
    "name": "BLACK",
    "memberof": "src/internal/tree-node.js",
    "static": true,
    "longname": "src/internal/tree-node.js~BLACK",
    "access": "private",
    "export": true,
    "importPath": "jstreemap/src/internal/tree-node.js",
    "importStyle": "{BLACK}",
    "description": "",
    "lineNumber": 10,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "variable",
    "name": "RED",
    "memberof": "src/internal/tree-node.js",
    "static": true,
    "longname": "src/internal/tree-node.js~RED",
    "access": "private",
    "export": true,
    "importPath": "jstreemap/src/internal/tree-node.js",
    "importStyle": "{RED}",
    "description": "",
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "file",
    "name": "src/internal/tree.js",
    "content": "'use strict';\r\n\r\n/** @ignore */\r\nconst {TreeNode, RED, BLACK} = require('./tree-node');\r\n/** @ignore */\r\nconst {JsIterator, JsReverseIterator} = require('../public/js-iterators');\r\n/** @ignore */\r\nconst {Iterator, ReverseIterator} = require('../public/iterators');\r\n/** @ignore */\r\nconst {KeyOnlyPolicy, ValueOnlyPolicy, KeyValuePolicy} = require('./policies');\r\n/** @ignore */\r\nconst {InsertionResult} = require('../public/insertion-result');\r\n\r\n/** insertion mode of a multimap, nodes with the same keys can be added */\r\nconst INSERT_MULTI = 1;\r\n/** if a node with the same key already exists then the subsequent attempts are ignored */\r\nconst INSERT_UNIQUE = 2;\r\n/** if a node with the same key already exists then it's value is replaced on subsequent attempts */\r\nconst INSERT_REPLACE = 3;\r\n\r\n/**\r\n * @private\r\n * Special node in a tree is created for performance reasons\r\n */\r\nclass Head {\r\n    /** default constructor */\r\n    constructor() {\r\n        /** node with the smallest key */\r\n        this.leftmost = this;\r\n        /** node with the largest key */\r\n        this.rightmost = this;\r\n        /** root node of the tree */\r\n        this.root = this;\r\n        /** number of nodes in the tree */\r\n        this.size = 0;\r\n        /** extra tag used in debuggin of unit tests */\r\n        this.id = 'HEAD';\r\n    }\r\n}\r\n\r\n/**\r\n * @private\r\n * 3-way comparison, similar to strcmp and memcp in C programming language\r\n * @returns +1 if the value of rhs is greater than lhs\r\n *          -1 if the value of rhs is less than lhs\r\n *           0 if values are the same\r\n */\r\nfunction compare(lhs, rhs) {\r\n    if (lhs < rhs) {\r\n        return -1;\r\n    }\r\n    else if (lhs === rhs) {\r\n        return 0;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Red-black tree\r\n * @access private\r\n */\r\nclass Tree {\r\n    /** default constructor of an empty tree */\r\n    constructor() {\r\n        /** head */\r\n        this.head = new Head();\r\n        /** 3-way comparison function */\r\n        this.compare = compare;\r\n        /** must be an instance of KeyOnlyPolicy for sets, or KeyValuePolicy for maps */\r\n        this.valuePolicy = new KeyOnlyPolicy();\r\n    }\r\n\r\n    /**\r\n     * Deletes all nodes in the tree\r\n     */\r\n    clear() {\r\n        this.head = new Head();\r\n    }\r\n\r\n    /**\r\n     * @returns number of nodes in the tree\r\n     */\r\n    size() {\r\n        return this.head.size;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * A wrapper that calls 3-way comparison of node keys\r\n     * @param {*} lhs\r\n     * @param {*} rhs\r\n     */\r\n    compareNodes(lhs, rhs) {\r\n        return this.compare(lhs.key, rhs.key);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * used by rotation operations\r\n     */\r\n    replaceNode(oldNode, newNode) {\r\n        if (oldNode === newNode) {\r\n            return;\r\n        }\r\n        if (oldNode.parent === null) {\r\n            this.head.root = newNode;\r\n        }\r\n        else {\r\n            if (oldNode === oldNode.parent.left) {\r\n                oldNode.parent.left = newNode;\r\n            }\r\n            else {\r\n                oldNode.parent.right = newNode;\r\n            }\r\n        }\r\n\r\n        if (!this.isLeaf(newNode)) {\r\n            newNode.parent = oldNode.parent;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebalances tree as described below\r\n\r\n              X                                           Y\r\n             / \\                                         / \\\r\n            Y   c         right rotate -->              a   X\r\n           / \\            <--  left rotate                 / \\\r\n          a   b                                           b   c\r\n     * @private\r\n     */\r\n    rotateLeft(node) {\r\n        let right = node.right;\r\n        if (this.isLeaf(right)) {\r\n            throw new Error('rotateLeft can\\'t be performed. The tree is corrupted');\r\n        }\r\n        this.replaceNode(node, right);\r\n\r\n        node.right = right.left;\r\n        if (right.left !== null) {\r\n            right.left.parent = node;\r\n        }\r\n\r\n        right.left = node;\r\n        node.parent = right;\r\n    }\r\n\r\n    /**\r\n     * Rebalances tree as described in rotateLeft\r\n     * @param {*} node - parent node\r\n     */\r\n    rotateRight(node) {\r\n        let left = node.left;\r\n        if (this.isLeaf(left)) {\r\n            throw new Error('rotateRight can\\'t be performed. The tree is corrupted');\r\n        }\r\n        this.replaceNode(node, left);\r\n\r\n        node.left = left.right;\r\n        if (left.right !== null) {\r\n            left.right.parent = node;\r\n        }\r\n\r\n        left.right = node;\r\n        node.parent = left;\r\n    }\r\n\r\n    /**\r\n     * @returns true - for null pointers and head node; false - for all other nodes\r\n     * @param {*} node\r\n     */\r\n    isLeaf(node) {\r\n        if (node === null || node === this.head) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Leaf nodes are considered 'black'. All real nodes contain 'color' data member\r\n     * @param {*} node\r\n     */\r\n    fetchColor(node) {\r\n        if (this.isLeaf(node)) {\r\n            return BLACK;\r\n        }\r\n        else {\r\n            return node.color;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests a node for 'blackness'.\r\n     * @param {*} node\r\n     */\r\n    isBlack(node) {\r\n        return (this.fetchColor(node) === BLACK);\r\n    }\r\n\r\n    /**\r\n     * Tests node for 'redness'.\r\n     * @param {*} node\r\n     */\r\n    isRed(node) {\r\n        return (this.fetchColor(node) === RED);\r\n    }\r\n\r\n    /* ===========================\r\n       INSERT\r\n       =========================== */\r\n    /**\r\n     * A node will be inserted into the tree even if nodes with the same key already exist\r\n     * @param {*} node\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     */\r\n    insertMulti(node) {\r\n        return this.insertNode(node, INSERT_MULTI);\r\n    }\r\n\r\n    /**\r\n     * The node is inserted into the tree only if nodes with the same key do not exist there\r\n     * @param {*} node\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     */\r\n    insertUnique(node) {\r\n        return this.insertNode(node, INSERT_UNIQUE);\r\n    }\r\n\r\n    /**\r\n     * The node is inserted. If a node with the same key exists it's value will be replaced by the value of the new node\r\n     * @param {*} node\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     */\r\n    insertOrReplace(node) {\r\n        return this.insertNode(node, INSERT_REPLACE);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Inserts node. Updates head node. Rebalances tree.\r\n     * @param {*} n - node\r\n     * @param {*} mode - one of INSERT_MULTI, INSERT_UNIQUE, INSERT_REPLACE\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     */\r\n    insertNode(n, mode = INSERT_MULTI) {\r\n        let res = this.insertNodeInternal(this.head.root, n, mode);\r\n        if (res.wasAdded) {\r\n            if (this.head.size === 0) {\r\n                this.head.root = n;\r\n                this.head.leftmost = n;\r\n                this.head.rightmost = n;\r\n\r\n                n.left = this.head;\r\n                n.right = this.head;\r\n            }\r\n            else if (this.head.leftmost.left === n) {\r\n                this.head.leftmost = n;\r\n                n.left = this.head;\r\n            }\r\n            else if (this.head.rightmost.right === n) {\r\n                this.head.rightmost = n;\r\n                n.right = this.head;\r\n            }\r\n            this.insertRepairTree(n);\r\n            this.head.size = this.head.size + 1;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Inserts node according to the mode\r\n     * @param {*} root - root node of the tree\r\n     * @param {*} n - node to be inserted\r\n     * @param {*} mode - one of INSERT_MULTI, INSERT_UNIQUE, INSERT_REPLACE\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     */\r\n    insertNodeInternal(root, n, mode) {\r\n        // recursively descend the tree until a leaf is found\r\n        let x = root;\r\n        let y = null;\r\n        let rc = -1;\r\n        // find matching node\r\n        while (!this.isLeaf(x)) {\r\n            y = x;\r\n            rc = this.compareNodes(n, y);\r\n            if (rc < 0) {\r\n                x = y.left;\r\n            }\r\n            else if (rc > 0) {\r\n                x = y.right;\r\n            }\r\n            else {\r\n                // node with the same key value\r\n                switch (mode) {\r\n                    case INSERT_UNIQUE:\r\n                        // it's a duplicate\r\n                        return new InsertionResult(false, false, undefined);\r\n                    case INSERT_REPLACE:\r\n                        this.valuePolicy.copy(y, n);\r\n                        return new InsertionResult(false, true, new Iterator(y, this));\r\n                    default:\r\n                        // INSERT_MULTI\r\n                        x = y.right;\r\n                }\r\n            }\r\n        }\r\n        if (this.isLeaf(y)) {\r\n            n.parent = null;\r\n            n.left = this.head;\r\n            n.right = this.head;\r\n        }\r\n        else {\r\n            n.parent = y;\r\n            if (rc < 0) {\r\n                y.left = n;\r\n            }\r\n            else {\r\n                y.right = n;\r\n            }\r\n        }\r\n        return new InsertionResult(true, false, new Iterator(n, this));\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Insertion\r\n     * @param {*} n - node\r\n     */\r\n    insertRepairTree(n) {\r\n        if (n.parent === null) {\r\n            this.repairCase1(n);\r\n        }\r\n        else if (this.isBlack(n.parent)) {\r\n        /* insert_case2(n);\r\n           // do nothing */\r\n        }\r\n        else if (this.isRed(n.uncle())) {\r\n            this.repairCase3(n);\r\n        }\r\n        else {\r\n            this.repairCase4(n);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Insertion\r\n     * @param {*} n - node\r\n     */\r\n    repairCase1(n) {\r\n        n.color = BLACK;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Insertion\r\n     * @param {*} n - node\r\n     */\r\n    repairCase3(n) {\r\n        n.parent.color = BLACK;\r\n        n.uncle().color = BLACK;\r\n        n.grandparent().color = RED;\r\n        this.insertRepairTree(n.grandparent());\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Insertion\r\n     * @param {*} n - node\r\n     */\r\n    repairCase4(n) {\r\n        let p = n.parent;\r\n        let g = n.grandparent();\r\n\r\n        let nr = null;\r\n        if ((g.left !== null)\r\n            && (n === g.left.right)) {\r\n            this.rotateLeft(p);\r\n            n = n.left;\r\n        }\r\n        else if ((g.right !== null)\r\n            && (n === g.right.left)) {\r\n            this.rotateRight(p);\r\n            n = n.right;\r\n        }\r\n\r\n        p = n.parent;\r\n        g = n.grandparent();\r\n        if (n === p.left) {\r\n            this.rotateRight(g);\r\n        }\r\n        else {\r\n            this.rotateLeft(g);\r\n        }\r\n\r\n        p.color = BLACK;\r\n        g.color = RED;\r\n    }\r\n\r\n    /**\r\n     * @returns the node with the highest key for the subtree of the specified root node\r\n     * @param {*} node - root node of the subtree to be evaluated\r\n     */\r\n    fetchMaximum(node) {\r\n        while (!this.isLeaf(node.right)) {\r\n            node = node.right;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * @returns the node with the lowest key for the subtree of the specified root node\r\n     * @param {*} node - root node of the subtree to be evaluated\r\n     */\r\n    fetchMinimum(node) {\r\n        while (!this.isLeaf(node.left)) {\r\n            node = node.left;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    /* ===========================\r\n       ERASE\r\n       =========================== */\r\n    /**\r\n     * Removes node from the tree\r\n     * @param {*} node\r\n     */\r\n    erase(node) {\r\n        if (this.isLeaf(node)) {\r\n            return;\r\n        }\r\n\r\n        this.eraseInternal(node);\r\n        let h = this.head;\r\n        h.size = h.size - 1;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal\r\n     * @param {*} node - node\r\n     */\r\n    eraseInternal(node) {\r\n        if (!this.isLeaf(node.left)\r\n            && !this.isLeaf(node.right)) {\r\n            let pred = this.fetchMaximum(node.left);\r\n\r\n            this.valuePolicy.copy(node, pred);\r\n            node = pred;\r\n        }\r\n\r\n        let child = (this.isLeaf(node.right)) ? node.left : node.right;\r\n\r\n        if (this.isBlack(node)) {\r\n            this.eraseCase1(node);\r\n        }\r\n        this.replaceNode(node, child);\r\n        if (this.head.size === 2) {\r\n            if (!this.isLeaf(child)) {\r\n                // Root node must be BLACK\r\n                child.color = BLACK;\r\n            }\r\n        }\r\n\r\n        let h = this.head;\r\n        if (this.isLeaf(child)) {\r\n            /* The node didn't have children and it was removed\r\n               the head needs to update leftmost, rightmost pointers */\r\n            if (h.leftmost === node) {\r\n                let p = node.parent;\r\n                if (p !== null) {\r\n                    h.leftmost = p;\r\n                    p.left = h;\r\n                }\r\n                else {\r\n                    h.leftmost = h;\r\n                }\r\n            }\r\n            if (h.rightmost === node) {\r\n                let p = node.parent;\r\n                if (p !== null) {\r\n                    h.rightmost = p;\r\n                    p.right = h;\r\n                }\r\n                else {\r\n                    h.rightmost = h;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // the node had a child. Now node is removed. Any references should point to the child now\r\n            if (h.leftmost === node) {\r\n                h.leftmost = child;\r\n                child.left = h;\r\n            }\r\n            if (h.rightmost === node) {\r\n                h.rightmost = child;\r\n                child.right = h;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal\r\n     * @param {*} node\r\n     */\r\n    eraseCase1(node) {\r\n        if (node.parent === null) {\r\n            return;\r\n        }\r\n        else {\r\n            this.eraseCase2(node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal\r\n     * @param {*} node\r\n     */\r\n    eraseCase2(node) {\r\n        let s = node.sibling();\r\n\r\n        if (this.isRed(s)) {\r\n            node.parent.color = RED;\r\n            s.color = BLACK;\r\n\r\n            if (node === node.parent.left) {\r\n                this.rotateLeft(node.parent);\r\n            }\r\n            else {\r\n                this.rotateRight(node.parent);\r\n            }\r\n        }\r\n        this.eraseCase3(node);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal\r\n     * @param {*} node\r\n     */\r\n    eraseCase3(node) {\r\n        let s = node.sibling();\r\n        let p = node.parent;\r\n        if (this.isBlack(p)\r\n            && this.isBlack(s)\r\n            && this.isBlack(s.left)\r\n            && this.isBlack(s.right)) {\r\n\r\n            s.color = RED;\r\n            this.eraseCase1(p);\r\n        }\r\n        else {\r\n            this.eraseCase4(node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal\r\n     * @param {*} node\r\n     */\r\n    eraseCase4(node) {\r\n        let s = node.sibling();\r\n        let p = node.parent;\r\n        if (this.isRed(p)\r\n            && this.isBlack(s)\r\n            && this.isBlack(s.left)\r\n            && this.isBlack(s.right)) {\r\n\r\n            s.color = RED;\r\n            p.color = BLACK;\r\n        }\r\n        else {\r\n            this.eraseCase5(node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal\r\n     * @param {*} node\r\n     */\r\n    eraseCase5(node) {\r\n        let s = node.sibling();\r\n        let p = node.parent;\r\n        /* The check below is unnecessary\r\n           due to case 2 (even though case 2 changed the sibling to a sibling's child,\r\n           the sibling's child can't be red, since no red parent can have a red child). */\r\n        /* if ((!this.isLeaf(s))\r\n               && this.isBlack(s)) { */\r\n\r\n        /* the following statements just force the red to be on the left of the left of the parent,\r\n           or right of the right, so case six will rotate correctly. */\r\n        if (node === p.left\r\n            && this.isRed(s.left)\r\n\t\t\t&& this.isBlack(s.right)) {\r\n\r\n            s.color = RED;\r\n            s.left.color = BLACK;\r\n            this.rotateRight(s);\r\n        }\r\n        else if (node === p.right\r\n            && this.isBlack(s.left)\r\n            && this.isRed(s.right)) {\r\n\r\n            s.color = RED;\r\n            s.right.color = BLACK;\r\n            this.rotateLeft(s);\r\n        }\r\n        //}\r\n        this.eraseCase6(node);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * The method is decribed at: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal\r\n     * @param {*} node\r\n     */\r\n    eraseCase6(node) {\r\n        let s = node.sibling();\r\n        let p = node.parent;\r\n        s.color = this.fetchColor(p);\r\n        p.color = BLACK;\r\n\r\n        if (node === p.left) {\r\n            s.right.color = BLACK;\r\n            this.rotateLeft(p);\r\n        }\r\n        else {\r\n            s.left.color = BLACK;\r\n            this.rotateRight(p);\r\n        }\r\n    }\r\n\r\n    /* ===========================\r\n       SEARCH BY KEY\r\n       =========================== */\r\n    /**\r\n    * @returns an iterator pointin to a node with matching key value. If node is not found then end() iterator is returned.\r\n    * @param {*} k - key value\r\n    */\r\n    find(k) {\r\n        let y = this.head;\r\n        let x = y.root;\r\n        while (!this.isLeaf(x)) {\r\n            let rc = this.compare(x.key, k);\r\n            if (rc > 0) {\r\n                y = x;\r\n                x = x.left;\r\n            }\r\n            else if (rc < 0) {\r\n                y = x;\r\n                x = x.right;\r\n            }\r\n            else {\r\n                return new Iterator(x, this);\r\n            }\r\n        }\r\n        return new Iterator(this.head, this);\r\n    }\r\n\r\n    /**\r\n     * @returns an iterator pointing to the first node in the tree that is not less than\r\n     * (i.e. greater or equal to) the specified key value, or end() if no such node is found.\r\n     * @param {*} k - key value\r\n     */\r\n    lowerBound(k) {\r\n        let y = this.head;\r\n        let x = y.root;\r\n        while (!this.isLeaf(x)) {\r\n            let rc = this.compare(x.key, k);\r\n            if (rc >= 0) {\r\n                y = x;\r\n                x = x.left;\r\n            }\r\n            else {\r\n                x = x.right;\r\n            }\r\n        }\r\n        return new Iterator(y, this);\r\n    }\r\n\r\n    /**\r\n     * @returns an iterator pointing to the first node in the tree that is greater than\r\n     * the specified key value, or end() if no such node is found.\r\n     * @param {*} k - key value\r\n     */\r\n    upperBound(k) {\r\n        let y = this.head;\r\n        let x = y.root;\r\n        while (!this.isLeaf(x)) {\r\n            let rc = this.compare(x.key, k);\r\n            if (rc > 0) {\r\n                y = x;\r\n                x = x.left;\r\n            }\r\n            else {\r\n                x = x.right;\r\n            }\r\n        }\r\n        return new Iterator(y, this);\r\n    }\r\n\r\n    /* ===========================\r\n       ITERATORS\r\n       =========================== */\r\n\r\n    /**\r\n     * @returns iterator pointing to the node with the lowest key\r\n     */\r\n    begin() {\r\n        return new Iterator(this.head.leftmost, this);\r\n    }\r\n\r\n    /**\r\n     * @returns iterator pointing to the node following the node with the highest key\r\n     */\r\n    end() {\r\n        return new Iterator(this.head, this);\r\n    }\r\n\r\n    /**\r\n     * @returns iterator pointing to the node with the highest key\r\n     */\r\n    rbegin() {\r\n        return new ReverseIterator(this.head.rightmost, this);\r\n    }\r\n\r\n    /**\r\n     * @returns iterator pointing to the node preceding the node with the lowest key\r\n     */\r\n    rend() {\r\n        return new ReverseIterator(this.head, this);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * provides support for ES6 forward iteration\r\n     */\r\n    jsBegin() {\r\n        return this.head.leftmost;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * provides support for ES6 forward iteration\r\n     */\r\n    jsEnd() {\r\n        return this.head;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * provides support for ES6 reverse iteration\r\n     */\r\n    jsRbegin() {\r\n        return this.head.rightmost;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * provides support for ES6 forward iteration\r\n     */\r\n    jsRend() {\r\n        return this.head;\r\n    }\r\n\r\n    /**\r\n     * @returns node following the specified node in ascending order of their keys\r\n     * @param {*} n - node\r\n     */\r\n    next(n) {\r\n        if (n === this.head) {\r\n            return this.head.leftmost;\r\n        }\r\n        if (n.right === this.head) {\r\n            return this.head;\r\n        }\r\n        if (n.right !== null) {\r\n            let res = this.fetchMinimum(n.right);\r\n            return res;\r\n        }\r\n        else {\r\n            while (n.parent.left !== n) {\r\n                n = n.parent;\r\n            }\r\n            return n.parent;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns node preceding the specified node in ascending order of their keys\r\n     * @param {*} n - node\r\n     */\r\n    prev(n) {\r\n        if (n === this.head) {\r\n            return this.head.rightmost;\r\n        }\r\n        if (n.left === this.head) {\r\n            return this.head;\r\n        }\r\n        if (n.left !== null) {\r\n            let res = this.fetchMaximum(n.left);\r\n            return res;\r\n        }\r\n        else {\r\n            while (n.parent.right !== n) {\r\n                n = n.parent;\r\n            }\r\n            return n.parent;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ES6 forward iteration\r\n     */\r\n    [Symbol.iterator]() {\r\n        return new JsIterator(this);\r\n    }\r\n\r\n    /**\r\n     * ES6 reverse iteration\r\n     */\r\n    backward() {\r\n        return new JsReverseIterator(this);\r\n    }\r\n\r\n    /**\r\n     * @returns a new JsIterator object that contains the [key, value] pairs for each element in the order of the keys.\r\n     */\r\n    entries() {\r\n        return new JsIterator(this);\r\n    }\r\n\r\n    /**\r\n     * @returns a new JsIterator object that contains the keys for each element in the order of the keys.\r\n     */\r\n    keys() {\r\n        return new JsIterator(this, new KeyOnlyPolicy());\r\n    }\r\n\r\n    /**\r\n     * @returns a new JsIterator object that contains the values for each element in the order of the keys.\r\n     */\r\n    values() {\r\n        return new JsIterator(this, new ValueOnlyPolicy());\r\n    }\r\n\r\n    /**\r\n     * @returns first element of the container, or undefined if container is empty\r\n     */\r\n    first() {\r\n        if (this.size() === 0) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            let it = this.begin();\r\n            return this.valuePolicy.fetch(it.node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns last element of the container, or undefined if container is empty\r\n     */\r\n    last() {\r\n        if (this.size() === 0) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            let it = this.rbegin();\r\n            return this.valuePolicy.fetch(it.node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns String representation of the container\r\n     */\r\n    toString() {\r\n        let parts = [];\r\n        for (let it = this.begin(); !it.equals(this.end()); it.next()) {\r\n            // convert each key-value pair\r\n            parts.push(this.valuePolicy.toString(it.node));\r\n        }\r\n        return '{' + parts.join(',') + '}';\r\n    }\r\n\r\n    /**\r\n     * @returns String tag of this class\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return 'Tree';\r\n    }\r\n\r\n    /**\r\n     * @returns constructor object for this class\r\n     */\r\n    static get [Symbol.species]() {\r\n        return Tree;\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = {\r\n    Tree: Tree,\r\n    compare: compare\r\n};\r\n",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/internal/tree.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 75,
    "kind": "variable",
    "name": "TreeNode",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~TreeNode",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "name": "JsIterator",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~JsIterator",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "name": "Iterator",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~Iterator",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "variable",
    "name": "KeyOnlyPolicy",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~KeyOnlyPolicy",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "variable",
    "name": "InsertionResult",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~InsertionResult",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "variable",
    "name": "INSERT_MULTI",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~INSERT_MULTI",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": "insertion mode of a multimap, nodes with the same keys can be added",
    "lineNumber": 15,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 81,
    "kind": "variable",
    "name": "INSERT_UNIQUE",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~INSERT_UNIQUE",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": "if a node with the same key already exists then the subsequent attempts are ignored",
    "lineNumber": 17,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 82,
    "kind": "variable",
    "name": "INSERT_REPLACE",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~INSERT_REPLACE",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": "if a node with the same key already exists then it's value is replaced on subsequent attempts",
    "lineNumber": 19,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 83,
    "kind": "class",
    "name": "Head",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~Head",
    "access": "private",
    "export": false,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 25,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 84,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/internal/tree.js~Head",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Head#constructor",
    "access": "public",
    "description": "default constructor",
    "lineNumber": 27
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "leftmost",
    "memberof": "src/internal/tree.js~Head",
    "static": false,
    "longname": "src/internal/tree.js~Head#leftmost",
    "access": "public",
    "description": "node with the smallest key",
    "lineNumber": 29,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "rightmost",
    "memberof": "src/internal/tree.js~Head",
    "static": false,
    "longname": "src/internal/tree.js~Head#rightmost",
    "access": "public",
    "description": "node with the largest key",
    "lineNumber": 31,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "root",
    "memberof": "src/internal/tree.js~Head",
    "static": false,
    "longname": "src/internal/tree.js~Head#root",
    "access": "public",
    "description": "root node of the tree",
    "lineNumber": 33,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "size",
    "memberof": "src/internal/tree.js~Head",
    "static": false,
    "longname": "src/internal/tree.js~Head#size",
    "access": "public",
    "description": "number of nodes in the tree",
    "lineNumber": 35,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "id",
    "memberof": "src/internal/tree.js~Head",
    "static": false,
    "longname": "src/internal/tree.js~Head#id",
    "access": "public",
    "description": "extra tag used in debuggin of unit tests",
    "lineNumber": 37,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "class",
    "name": "Tree",
    "memberof": "src/internal/tree.js",
    "static": true,
    "longname": "src/internal/tree.js~Tree",
    "access": "private",
    "export": true,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": "{Tree}",
    "description": "Red-black tree",
    "lineNumber": 64,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 91,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#constructor",
    "access": "public",
    "description": "default constructor of an empty tree",
    "lineNumber": 66
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "head",
    "memberof": "src/internal/tree.js~Tree",
    "static": false,
    "longname": "src/internal/tree.js~Tree#head",
    "access": "public",
    "description": "head",
    "lineNumber": 68,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "compare",
    "memberof": "src/internal/tree.js~Tree",
    "static": false,
    "longname": "src/internal/tree.js~Tree#compare",
    "access": "public",
    "description": "3-way comparison function",
    "lineNumber": 70,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "valuePolicy",
    "memberof": "src/internal/tree.js~Tree",
    "static": false,
    "longname": "src/internal/tree.js~Tree#valuePolicy",
    "access": "public",
    "description": "must be an instance of KeyOnlyPolicy for sets, or KeyValuePolicy for maps",
    "lineNumber": 72,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "clear",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#clear",
    "access": "public",
    "description": "Deletes all nodes in the tree",
    "lineNumber": 78,
    "params": [],
    "return": null
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "size",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#size",
    "access": "public",
    "description": "",
    "lineNumber": 85,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "number of nodes in the tree"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "number of nodes in the tree"
    },
    "params": []
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "compareNodes",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#compareNodes",
    "access": "private",
    "description": "",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "lhs",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "rhs",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "replaceNode",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#replaceNode",
    "access": "private",
    "description": "",
    "lineNumber": 103,
    "ignore": true,
    "params": [
      {
        "name": "oldNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "newNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "rotateLeft",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#rotateLeft",
    "access": "private",
    "description": "Rebalances tree as described below\n\nX                                           Y\n/ \\                                         / \\\nY   c         right rotate -->              a   X\n/ \\            <--  left rotate                 / \\\na   b                                           b   c",
    "lineNumber": 134,
    "ignore": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "rotateRight",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#rotateRight",
    "access": "public",
    "description": "Rebalances tree as described in rotateLeft",
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "parent node"
      }
    ],
    "return": null
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "isLeaf",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#isLeaf",
    "access": "public",
    "description": "",
    "lineNumber": 174,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "true - for null pointers and head node; false - for all other nodes"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true - for null pointers and head node; false - for all other nodes"
    }
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "fetchColor",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#fetchColor",
    "access": "public",
    "description": "Leaf nodes are considered 'black'. All real nodes contain 'color' data member",
    "lineNumber": 185,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "isBlack",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#isBlack",
    "access": "public",
    "description": "Tests a node for 'blackness'.",
    "lineNumber": 198,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "isRed",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#isRed",
    "access": "public",
    "description": "Tests node for 'redness'.",
    "lineNumber": 206,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "insertMulti",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#insertMulti",
    "access": "public",
    "description": "A node will be inserted into the tree even if nodes with the same key already exist",
    "lineNumber": 218,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "insertUnique",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#insertUnique",
    "access": "public",
    "description": "The node is inserted into the tree only if nodes with the same key do not exist there",
    "lineNumber": 227,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "insertOrReplace",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#insertOrReplace",
    "access": "public",
    "description": "The node is inserted. If a node with the same key exists it's value will be replaced by the value of the new node",
    "lineNumber": 236,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "insertNode",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#insertNode",
    "access": "private",
    "description": "",
    "lineNumber": 247,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "node"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": "one of INSERT_MULTI, INSERT_UNIQUE, INSERT_REPLACE"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    },
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "insertNodeInternal",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#insertNodeInternal",
    "access": "private",
    "description": "",
    "lineNumber": 280,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "root",
        "description": "root node of the tree"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "node to be inserted"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": "one of INSERT_MULTI, INSERT_UNIQUE, INSERT_REPLACE"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    },
    "ignore": true
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "insertRepairTree",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#insertRepairTree",
    "access": "private",
    "description": "",
    "lineNumber": 332,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "node"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "repairCase1",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#repairCase1",
    "access": "private",
    "description": "",
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "node"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "repairCase3",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#repairCase3",
    "access": "private",
    "description": "",
    "lineNumber": 362,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "node"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "repairCase4",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#repairCase4",
    "access": "private",
    "description": "",
    "lineNumber": 374,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "node"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "fetchMaximum",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#fetchMaximum",
    "access": "public",
    "description": "",
    "lineNumber": 407,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "the node with the highest key for the subtree of the specified root node"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "root node of the subtree to be evaluated"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the node with the highest key for the subtree of the specified root node"
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "fetchMinimum",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#fetchMinimum",
    "access": "public",
    "description": "",
    "lineNumber": 419,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "the node with the lowest key for the subtree of the specified root node"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "root node of the subtree to be evaluated"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the node with the lowest key for the subtree of the specified root node"
    }
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "erase",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#erase",
    "access": "public",
    "description": "Removes node from the tree",
    "lineNumber": 434,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "eraseInternal",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#eraseInternal",
    "access": "private",
    "description": "",
    "lineNumber": 449,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "node"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "eraseCase1",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#eraseCase1",
    "access": "private",
    "description": "",
    "lineNumber": 514,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "eraseCase2",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#eraseCase2",
    "access": "private",
    "description": "",
    "lineNumber": 528,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "eraseCase3",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#eraseCase3",
    "access": "private",
    "description": "",
    "lineNumber": 550,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "eraseCase4",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#eraseCase4",
    "access": "private",
    "description": "",
    "lineNumber": 571,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "eraseCase5",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#eraseCase5",
    "access": "private",
    "description": "",
    "lineNumber": 592,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "eraseCase6",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#eraseCase6",
    "access": "private",
    "description": "",
    "lineNumber": 628,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "find",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#find",
    "access": "public",
    "description": "",
    "lineNumber": 651,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "an iterator pointin to a node with matching key value. If node is not found then end() iterator is returned."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "k",
        "description": "key value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "an iterator pointin to a node with matching key value. If node is not found then end() iterator is returned."
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "lowerBound",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#lowerBound",
    "access": "public",
    "description": "",
    "lineNumber": 676,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "an iterator pointing to the first node in the tree that is not less than\n(i.e. greater or equal to) the specified key value, or end() if no such node is found."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "k",
        "description": "key value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "an iterator pointing to the first node in the tree that is not less than\n(i.e. greater or equal to) the specified key value, or end() if no such node is found."
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "upperBound",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#upperBound",
    "access": "public",
    "description": "",
    "lineNumber": 697,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "an iterator pointing to the first node in the tree that is greater than\nthe specified key value, or end() if no such node is found."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "k",
        "description": "key value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "an iterator pointing to the first node in the tree that is greater than\nthe specified key value, or end() if no such node is found."
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "begin",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#begin",
    "access": "public",
    "description": "",
    "lineNumber": 720,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "iterator pointing to the node with the lowest key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "iterator pointing to the node with the lowest key"
    },
    "params": []
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "end",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#end",
    "access": "public",
    "description": "",
    "lineNumber": 727,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "iterator pointing to the node following the node with the highest key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "iterator pointing to the node following the node with the highest key"
    },
    "params": []
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "rbegin",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#rbegin",
    "access": "public",
    "description": "",
    "lineNumber": 734,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "iterator pointing to the node with the highest key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "iterator pointing to the node with the highest key"
    },
    "params": []
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "rend",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#rend",
    "access": "public",
    "description": "",
    "lineNumber": 741,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "iterator pointing to the node preceding the node with the lowest key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "iterator pointing to the node preceding the node with the lowest key"
    },
    "params": []
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "jsBegin",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#jsBegin",
    "access": "private",
    "description": "",
    "lineNumber": 749,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "jsEnd",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#jsEnd",
    "access": "private",
    "description": "",
    "lineNumber": 757,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "jsRbegin",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#jsRbegin",
    "access": "private",
    "description": "",
    "lineNumber": 765,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "jsRend",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#jsRend",
    "access": "private",
    "description": "",
    "lineNumber": 773,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "next",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#next",
    "access": "public",
    "description": "",
    "lineNumber": 781,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "node following the specified node in ascending order of their keys"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "node"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "node following the specified node in ascending order of their keys"
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "prev",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#prev",
    "access": "public",
    "description": "",
    "lineNumber": 804,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "node preceding the specified node in ascending order of their keys"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "node"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "node preceding the specified node in ascending order of their keys"
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#[Symbol.iterator]",
    "access": "public",
    "description": "ES6 forward iteration",
    "lineNumber": 826,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "backward",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#backward",
    "access": "public",
    "description": "ES6 reverse iteration",
    "lineNumber": 833,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "entries",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#entries",
    "access": "public",
    "description": "",
    "lineNumber": 840,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "a new JsIterator object that contains the [key, value] pairs for each element in the order of the keys."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a new JsIterator object that contains the [key, value] pairs for each element in the order of the keys."
    },
    "params": []
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "keys",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#keys",
    "access": "public",
    "description": "",
    "lineNumber": 847,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "a new JsIterator object that contains the keys for each element in the order of the keys."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a new JsIterator object that contains the keys for each element in the order of the keys."
    },
    "params": []
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "values",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#values",
    "access": "public",
    "description": "",
    "lineNumber": 854,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "a new JsIterator object that contains the values for each element in the order of the keys."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a new JsIterator object that contains the values for each element in the order of the keys."
    },
    "params": []
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "first",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#first",
    "access": "public",
    "description": "",
    "lineNumber": 861,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "first element of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "first element of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "last",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#last",
    "access": "public",
    "description": "",
    "lineNumber": 874,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "last element of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "last element of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "toString",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#toString",
    "access": "public",
    "description": "",
    "lineNumber": 887,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "String representation of the container"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "String representation of the container"
    },
    "params": []
  },
  {
    "__docId__": 146,
    "kind": "get",
    "name": "[Symbol.toStringTag]",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/internal/tree.js~Tree#[Symbol.toStringTag]",
    "access": "public",
    "description": "",
    "lineNumber": 899,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "String tag of this class"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "String tag of this class"
    },
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "get",
    "name": "[Symbol.species]",
    "memberof": "src/internal/tree.js~Tree",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/internal/tree.js~Tree.[Symbol.species]",
    "access": "public",
    "description": "",
    "lineNumber": 906,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "constructor object for this class"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "constructor object for this class"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "function",
    "name": "compare",
    "memberof": "src/internal/tree.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/internal/tree.js~compare",
    "access": "private",
    "export": true,
    "importPath": "jstreemap/src/internal/tree.js",
    "importStyle": "{compare}",
    "description": "",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "+1 if the value of rhs is greater than lhs\n         -1 if the value of rhs is less than lhs\n          0 if values are the same"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "+1 if the value of rhs is greater than lhs\n         -1 if the value of rhs is less than lhs\n          0 if values are the same"
    },
    "ignore": true,
    "params": [
      {
        "name": "lhs",
        "types": [
          "*"
        ]
      },
      {
        "name": "rhs",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 149,
    "kind": "file",
    "name": "src/public/insertion-result.js",
    "content": "/**\r\n * An instance of this class reports whether insert operation was successful.\r\n * if a node was added, or an existing one replaced then an iterator is provided. Otherwise the value of iterator is undefined\r\n */\r\nclass InsertionResult {\r\n    /**\r\n     * Default constructor\r\n     * @param {Boolean} wasAdded\r\n     * @param {Boolean} wasReplaced\r\n     * @param {Iterator} iterator only provided if the node was added, or replaced\r\n     */\r\n    constructor(wasAdded, wasReplaced, iterator) {\r\n        /**\r\n         * Boolean flag indicating whether an element was added\r\n         */\r\n        this.wasAdded = wasAdded;\r\n        /**\r\n         * Boolean flag indicating whether an existing node was updated\r\n         */\r\n        this.wasReplaced = wasReplaced;\r\n        /**\r\n         * {Iterator} instance pointing to the newly added node\r\n         */\r\n        this.iterator = iterator;\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    InsertionResult: InsertionResult\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/public/insertion-result.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 150,
    "kind": "class",
    "name": "InsertionResult",
    "memberof": "src/public/insertion-result.js",
    "static": true,
    "longname": "src/public/insertion-result.js~InsertionResult",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/insertion-result.js",
    "importStyle": "{InsertionResult}",
    "description": "An instance of this class reports whether insert operation was successful.\nif a node was added, or an existing one replaced then an iterator is provided. Otherwise the value of iterator is undefined",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 151,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/insertion-result.js~InsertionResult",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/insertion-result.js~InsertionResult#constructor",
    "access": "public",
    "description": "Default constructor",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "wasAdded",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "wasReplaced",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Iterator"
        ],
        "spread": false,
        "optional": false,
        "name": "iterator",
        "description": "only provided if the node was added, or replaced"
      }
    ]
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "wasAdded",
    "memberof": "src/public/insertion-result.js~InsertionResult",
    "static": false,
    "longname": "src/public/insertion-result.js~InsertionResult#wasAdded",
    "access": "public",
    "description": "Boolean flag indicating whether an element was added",
    "lineNumber": 16,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "wasReplaced",
    "memberof": "src/public/insertion-result.js~InsertionResult",
    "static": false,
    "longname": "src/public/insertion-result.js~InsertionResult#wasReplaced",
    "access": "public",
    "description": "Boolean flag indicating whether an existing node was updated",
    "lineNumber": 20,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "iterator",
    "memberof": "src/public/insertion-result.js~InsertionResult",
    "static": false,
    "longname": "src/public/insertion-result.js~InsertionResult#iterator",
    "access": "public",
    "description": "{Iterator} instance pointing to the newly added node",
    "lineNumber": 24,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "file",
    "name": "src/public/iterators.js",
    "content": "'use strict';\r\n/**\r\n * Base class for STL-like iterators. It references a node (or index) and a container.\r\n * Navigation is achieved by calling container's prev() and next() methods.\r\n */\r\nclass BaseIterator {\r\n    /**\r\n     * @param {*} node - current node\r\n     * @param {*} container - container\r\n     */\r\n    constructor(node, container) {\r\n        /**\r\n         * @private\r\n         * __n - internal node reference\r\n         */\r\n        this.__n = node;\r\n        /**\r\n         * @private\r\n         * __c - internal container reference\r\n         */\r\n        this.__c = container;\r\n    }\r\n\r\n    /**\r\n     * Two iterators are considered to be equal if they point to the same node of the same container\r\n     * @param {BaseIterator} rhs - object on the 'right-hand side' of .eq. operator\r\n     * @returns {boolean}\r\n     */\r\n    equals(rhs) {\r\n        let lhsClass = this.constructor.name;\r\n        let rhsClass = rhs.constructor.name;\r\n        if (lhsClass !== rhsClass) {\r\n            throw new Error(`Can't compare an instance of ${lhsClass} with an instance of ${rhsClass}`);\r\n        }\r\n        if (this.__c !== rhs.__c) {\r\n            throw new Error('Iterators belong to different containers');\r\n        }\r\n        return this.__n === rhs.__n;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @returns current node\r\n     */\r\n    get node() {\r\n        return this.__n;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @returns key of the current node\r\n     */\r\n    get key() {\r\n        return this.__n.key;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @returns value of the current node\r\n     */\r\n    get value() {\r\n        return this.__n.value;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @returns container that holds current node\r\n     */\r\n    get container() {\r\n        return this.__c;\r\n    }\r\n}\r\n\r\n/**\r\n * STL-like forward iterator. It's more verbose than ES6 iterators, but allows iteration over any part of the container\r\n *\r\n * @example\r\n * let m = new TreeMap();\r\n * ...\r\n * for (let it = m.begin(); !it.equals(m.end()); it.next()) {\r\n *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n * }\r\n */\r\nclass Iterator extends BaseIterator {\r\n    /**\r\n     * There are 3 ways to construct an iterator:\r\n     *\r\n     * 1. Using a node and a container\r\n     * 2. Copy constructor / clone\r\n     * 3. Copy constructor / clone from ReverseIterator instance\r\n     * @param {*} args\r\n     *\r\n     * @example\r\n     * // Using a node and a container\r\n     * let it = new Iterator(node, container);\r\n     *\r\n     * // Copy constructor / clone\r\n     * let it1 = new Iterator(node, container);\r\n     * let it2 = new Iterator(it1);\r\n     *\r\n     * // Copy constructor / clone from ReverseIterator instance\r\n     * let it1 = new ReverseIterator(node, container);\r\n     * let it2 = new Iterator(it1);\r\n     */\r\n    constructor(...args) {\r\n        if (args.length === 2) {\r\n            let [node, container] = args;\r\n            super(node, container);\r\n        }\r\n        else if (args.length === 1) {\r\n            let [obj] = args;\r\n            let className = obj.constructor.name;\r\n            if (className === Iterator.name) {\r\n                super(obj.__n, obj.__c);\r\n            }\r\n            // eslint-disable-next-line no-use-before-define\r\n            else if (className === ReverseIterator.name) {\r\n                let c = obj.__c;\r\n                super(c.next(obj.__n), c);\r\n            }\r\n            else {\r\n                throw new Error(`Can't create an Iterator from ${className}`);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Can\\'t create an Iterator with provided parameters');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces node reference with the reference of the next node in the container.\r\n     * Can be used for manual iteration over a range of key-value pairs.\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * let from = t.lowerBound(0);\r\n     * let to = t.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    next() {\r\n        /**\r\n         * __n and __c are defined in the base class\r\n         */\r\n        this.__n = this.__c.next(this.__n);\r\n    }\r\n\r\n    /**\r\n     * Replaces node reference with the reference of the previous node in the container\r\n     * Can be used for manual reverse iteration over a range of key-value pairs.\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * let from = t.lowerBound(0);\r\n     * let to = t.upperBound(50);\r\n     * let it = to;\r\n     * while (!it.equals(from)) {\r\n     *   it.prev();\r\n     *   console.log(it.key);\r\n     * }\r\n     */\r\n    prev() {\r\n        this.__n = this.__c.prev(this.__n);\r\n    }\r\n}\r\n\r\n/**\r\n * STL-like backward iterator. Can be used to traverse container or a range in the reverse order.\r\n * It's more verbose than ES6 iterators, but allows iteration over any part of the container\r\n *\r\n * @example\r\n * let m = new TreeMap();\r\n * ...\r\n * for (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\r\n *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n * }\r\n */\r\nclass ReverseIterator extends BaseIterator {\r\n    /**\r\n     * There are 3 ways to construct a reverse iterator:\r\n     *\r\n     * 1. Using a node and a container\r\n     * 2. Copy constructor / clone\r\n     * 3. Copy constructor / clone from forward Iterator instance\r\n     * @param {*} args\r\n     *\r\n     * @example\r\n     * // Using a node and a container\r\n     * let it = new ReverseIterator(node, container);\r\n     *\r\n     * // Copy constructor / clone\r\n     * let it1 = new ReverseIterator(node, container);\r\n     * let it2 = new ReverseIterator(it1);\r\n     *\r\n     * // Copy constructor / clone from forward Iterator instance\r\n     * let it1 = new Iterator(node, container);\r\n     * let it2 = new ReverseIterator(it1);\r\n     */\r\n    constructor(...args) {\r\n        if (args.length === 2) {\r\n            let [node, container] = args;\r\n            super(node, container);\r\n        }\r\n        else if (args.length === 1) {\r\n            let [obj] = args;\r\n            let className = obj.constructor.name;\r\n            if (className === ReverseIterator.name) {\r\n                super(obj.__n, obj.__c);\r\n            }\r\n            else if (className === Iterator.name) {\r\n                let c = obj.__c;\r\n                super(c.prev(obj.__n), c);\r\n            }\r\n            else {\r\n                throw new Error(`Can't create an ReverseIterator from ${className}`);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Can\\'t create a Reverse Iterator with provided parameters');\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Replaces node reference with the reference of the previous node in the container, because it works in reverse order\r\n     * Can be used for manual reverse iteration over a range of key-value pairs.\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * let from = new ReverseIterator(t.upperBound(50));\r\n     * let to = new ReverseIterator(t.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    next() {\r\n        /**\r\n         * __n and __c are defined in the base class\r\n         */\r\n        this.__n = this.__c.prev(this.__n);\r\n    }\r\n\r\n    /**\r\n     *  Replaces node reference with the reference of the next node in the container, because it works in reverse order\r\n     * Can be used for manual forward iteration over a range of key-value pairs.\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * let from = new ReverseIterator(t.upperBound(50));\r\n     * let to = new ReverseIterator(t.lowerBound(0));\r\n     * let it = to;\r\n     * while (!it.equals(from)) {\r\n     *   it.prev();\r\n     *   console.log(it.key);\r\n     * }\r\n     */\r\n    prev() {\r\n        this.__n = this.__c.next(this.__n);\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    Iterator: Iterator,\r\n    ReverseIterator: ReverseIterator\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/public/iterators.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 156,
    "kind": "class",
    "name": "BaseIterator",
    "memberof": "src/public/iterators.js",
    "static": true,
    "longname": "src/public/iterators.js~BaseIterator",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/iterators.js",
    "importStyle": null,
    "description": "Base class for STL-like iterators. It references a node (or index) and a container.\nNavigation is achieved by calling container's prev() and next() methods.",
    "lineNumber": 6,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/iterators.js~BaseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~BaseIterator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "current node"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "container",
        "description": "container"
      }
    ]
  },
  {
    "__docId__": 158,
    "kind": "member",
    "name": "__n",
    "memberof": "src/public/iterators.js~BaseIterator",
    "static": false,
    "longname": "src/public/iterators.js~BaseIterator#__n",
    "access": "private",
    "description": "",
    "lineNumber": 16,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "__c",
    "memberof": "src/public/iterators.js~BaseIterator",
    "static": false,
    "longname": "src/public/iterators.js~BaseIterator#__c",
    "access": "private",
    "description": "",
    "lineNumber": 21,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "equals",
    "memberof": "src/public/iterators.js~BaseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~BaseIterator#equals",
    "access": "public",
    "description": "Two iterators are considered to be equal if they point to the same node of the same container",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BaseIterator"
        ],
        "spread": false,
        "optional": false,
        "name": "rhs",
        "description": "object on the 'right-hand side' of .eq. operator"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 161,
    "kind": "get",
    "name": "node",
    "memberof": "src/public/iterators.js~BaseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~BaseIterator#node",
    "access": "private",
    "description": "",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "current node"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "current node"
    },
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "get",
    "name": "key",
    "memberof": "src/public/iterators.js~BaseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~BaseIterator#key",
    "access": "private",
    "description": "",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "key of the current node"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "key of the current node"
    },
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "get",
    "name": "value",
    "memberof": "src/public/iterators.js~BaseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~BaseIterator#value",
    "access": "private",
    "description": "",
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "value of the current node"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "value of the current node"
    },
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "get",
    "name": "container",
    "memberof": "src/public/iterators.js~BaseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~BaseIterator#container",
    "access": "private",
    "description": "",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "container that holds current node"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "container that holds current node"
    },
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "class",
    "name": "Iterator",
    "memberof": "src/public/iterators.js",
    "static": true,
    "longname": "src/public/iterators.js~Iterator",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/iterators.js",
    "importStyle": "{Iterator}",
    "description": "STL-like forward iterator. It's more verbose than ES6 iterators, but allows iteration over any part of the container",
    "examples": [
      "let m = new TreeMap();\n...\nfor (let it = m.begin(); !it.equals(m.end()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 84,
    "interface": false,
    "extends": [
      "BaseIterator"
    ]
  },
  {
    "__docId__": 166,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/iterators.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~Iterator#constructor",
    "access": "public",
    "description": "There are 3 ways to construct an iterator:\n\n1. Using a node and a container\n2. Copy constructor / clone\n3. Copy constructor / clone from ReverseIterator instance",
    "examples": [
      "// Using a node and a container\nlet it = new Iterator(node, container);\n\n// Copy constructor / clone\nlet it1 = new Iterator(node, container);\nlet it2 = new Iterator(it1);\n\n// Copy constructor / clone from ReverseIterator instance\nlet it1 = new ReverseIterator(node, container);\nlet it2 = new Iterator(it1);"
    ],
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "next",
    "memberof": "src/public/iterators.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~Iterator#next",
    "access": "public",
    "description": "Replaces node reference with the reference of the next node in the container.\nCan be used for manual iteration over a range of key-value pairs.",
    "examples": [
      "let m = new TreeMap();\n... // add key-value pairs., using numbers as keys\nlet from = t.lowerBound(0);\nlet to = t.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 144,
    "params": [],
    "return": null
  },
  {
    "__docId__": 168,
    "kind": "member",
    "name": "__n",
    "memberof": "src/public/iterators.js~Iterator",
    "static": false,
    "longname": "src/public/iterators.js~Iterator#__n",
    "access": "private",
    "description": "__n and __c are defined in the base class",
    "lineNumber": 148,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "prev",
    "memberof": "src/public/iterators.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~Iterator#prev",
    "access": "public",
    "description": "Replaces node reference with the reference of the previous node in the container\nCan be used for manual reverse iteration over a range of key-value pairs.",
    "examples": [
      "let m = new TreeMap();\n... // add key-value pairs., using numbers as keys\nlet from = t.lowerBound(0);\nlet to = t.upperBound(50);\nlet it = to;\nwhile (!it.equals(from)) {\n  it.prev();\n  console.log(it.key);\n}"
    ],
    "lineNumber": 165,
    "params": [],
    "return": null
  },
  {
    "__docId__": 171,
    "kind": "class",
    "name": "ReverseIterator",
    "memberof": "src/public/iterators.js",
    "static": true,
    "longname": "src/public/iterators.js~ReverseIterator",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/iterators.js",
    "importStyle": "{ReverseIterator}",
    "description": "STL-like backward iterator. Can be used to traverse container or a range in the reverse order.\nIt's more verbose than ES6 iterators, but allows iteration over any part of the container",
    "examples": [
      "let m = new TreeMap();\n...\nfor (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 181,
    "interface": false,
    "extends": [
      "BaseIterator"
    ]
  },
  {
    "__docId__": 172,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/iterators.js~ReverseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~ReverseIterator#constructor",
    "access": "public",
    "description": "There are 3 ways to construct a reverse iterator:\n\n1. Using a node and a container\n2. Copy constructor / clone\n3. Copy constructor / clone from forward Iterator instance",
    "examples": [
      "// Using a node and a container\nlet it = new ReverseIterator(node, container);\n\n// Copy constructor / clone\nlet it1 = new ReverseIterator(node, container);\nlet it2 = new ReverseIterator(it1);\n\n// Copy constructor / clone from forward Iterator instance\nlet it1 = new Iterator(node, container);\nlet it2 = new ReverseIterator(it1);"
    ],
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "next",
    "memberof": "src/public/iterators.js~ReverseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~ReverseIterator#next",
    "access": "public",
    "description": " Replaces node reference with the reference of the previous node in the container, because it works in reverse order\nCan be used for manual reverse iteration over a range of key-value pairs.",
    "examples": [
      "let m = new TreeMap();\n... // add key-value pairs., using numbers as keys\nlet from = new ReverseIterator(t.upperBound(50));\nlet to = new ReverseIterator(t.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 240,
    "params": [],
    "return": null
  },
  {
    "__docId__": 174,
    "kind": "member",
    "name": "__n",
    "memberof": "src/public/iterators.js~ReverseIterator",
    "static": false,
    "longname": "src/public/iterators.js~ReverseIterator#__n",
    "access": "private",
    "description": "__n and __c are defined in the base class",
    "lineNumber": 244,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "prev",
    "memberof": "src/public/iterators.js~ReverseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/iterators.js~ReverseIterator#prev",
    "access": "public",
    "description": " Replaces node reference with the reference of the next node in the container, because it works in reverse order\nCan be used for manual forward iteration over a range of key-value pairs.",
    "examples": [
      "let m = new TreeMap();\n... // add key-value pairs., using numbers as keys\nlet from = new ReverseIterator(t.upperBound(50));\nlet to = new ReverseIterator(t.lowerBound(0));\nlet it = to;\nwhile (!it.equals(from)) {\n  it.prev();\n  console.log(it.key);\n}"
    ],
    "lineNumber": 261,
    "params": [],
    "return": null
  },
  {
    "__docId__": 177,
    "kind": "file",
    "name": "src/public/js-iterators.js",
    "content": "'use strict';\r\n\r\n/* Containers are expected to support the following methods:\r\n   jsBegin() - returns the very first node\r\n   jsEnd() - returns the node beyond the last one\r\n   next(node) - returns the next node\r\n   prev(node) - returns the previous node\r\n   valuePolicy - an instance of KeyOnlyPolicy, or KeyValuePolicy */\r\n/**\r\n  * ES6-style forward iterator.\r\n  *\r\n  * @example\r\n  * let m = new TreeMap();\r\n  * ...\r\n  * for (let [key, value] of m) {\r\n  *   console.log(`key: ${key}, value: ${value}`);\r\n  * }\r\n  * // iterate values\r\n  * for (let value of m.values()) {\r\n  *   console.log(`value: ${value}`);\r\n  * }\r\n  */\r\nclass JsIterator {\r\n    /**\r\n     * @param {*} container\r\n     */\r\n    constructor(container, valuePolicy = container.valuePolicy) {\r\n        /**\r\n         * @private\r\n         * Internal reference to a container\r\n         */\r\n        this.container = container;\r\n        /**\r\n         * @private\r\n         * valuePolicy implements what members of the node will be returned: key, value, or key and value\r\n         */\r\n        this.valuePolicy = valuePolicy;\r\n        /**\r\n         * @private\r\n         * current node\r\n         */\r\n        this.node = container.jsBegin();\r\n    }\r\n\r\n    /**\r\n     * As documented in ES6 iteration protocol. It can be used for manual iteration.\r\n     * Iterators are documented here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\r\n     *\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ...\r\n     * let jsIt = m.entries();\r\n     * while (true) {\r\n     *   let res = it.next();\r\n     *   if (res.done) {\r\n     *     break;\r\n     *   }\r\n     *   console.log(`key: ${res.value[0]}, value: ${res.value[1]`});\r\n     * }\r\n     */\r\n    next() {\r\n        let res = {};\r\n        res.done = (this.node === this.container.jsEnd());\r\n        if (!res.done) {\r\n            res.value = this.valuePolicy.fetch(this.node);\r\n            this.node = this.container.next(this.node);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Support for ES6 for-of loops.\r\n     * @returns {JsIterator}\r\n     */\r\n    [Symbol.iterator]() {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A reverse iterator for the same container.\r\n     * @returns {JsReverseIterator}\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ...\r\n     * // iterate all key-value pairs in reverse order\r\n     * for (let [key, value] of m.backwards()) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n    */\r\n    backwards() {\r\n        // eslint-disable-next-line no-use-before-define\r\n        return new JsReverseIterator(this.container, this.valuePolicy);\r\n    }\r\n}\r\n\r\n/* Containers are expected to support the following methods:\r\n   jsRbegin() - returns the very first node in reverse order (e.g. the very last node)\r\n   jsrEnd() - returns the node beyond the last one in reverse order (e.g. the node before the first one)\r\n   next(node) - returns the next node\r\n   prev(node) - returns the previous node\r\n   valuePolicy - an instance of KeyOnlyPolicy, or KeyValuePolicy */\r\n/**\r\n  * ES6-style backward iterator\r\n  * @example\r\n  * let m = new TreeMap();\r\n  * ...\r\n  * // iterate all key-value pairs in reverse order\r\n  * for (let [key, value] of m.backwards()) {\r\n  *   console.log(`key: ${key}, value: ${value}`);\r\n  * }\r\n  * // iterate keys in reverse order\r\n  * for (let key of m.keys().backwards()) {\r\n  *   console.log(`key: ${key}`);\r\n  * }\r\n */\r\nclass JsReverseIterator {\r\n    /**\r\n     * @param {*} container\r\n     */\r\n    constructor(container, valuePolicy = container.valuePolicy) {\r\n        /**\r\n         * @private\r\n         * Internal reference to a container\r\n         */\r\n        this.container = container;\r\n        /**\r\n         * @private\r\n         * valuePolicy implements what members of the node will be returned: key, value, or key and value\r\n         */\r\n        this.valuePolicy = valuePolicy;\r\n        /**\r\n         * @private\r\n         * current node\r\n         */\r\n        this.node = container.jsRbegin();\r\n    }\r\n\r\n    /**\r\n     * As documented in ES6 iteration protocol. It can be used for manual iteration.\r\n     * Iterators are documented here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\r\n     *\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ...\r\n     * let jsIt = m.entries().backwards();\r\n     * while (true) {\r\n     *   let res = it.next();\r\n     *   if (res.done) {\r\n     *     break;\r\n     *   }\r\n     *   console.log(`key: ${res.value[0]}, value: ${res.value[1]`});\r\n     * }\r\n     */\r\n    next() {\r\n        let res = {};\r\n        res.done = (this.node === this.container.jsRend());\r\n        if (!res.done) {\r\n            res.value = this.valuePolicy.fetch(this.node);\r\n            this.node = this.container.prev(this.node);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Support for ES6 for-of loops.\r\n     * @returns {JsReverseIterator}\r\n     */\r\n    [Symbol.iterator]() {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A forward iterator for the same container\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ...\r\n     * // iterate all key-value pairs in direct order\r\n     * for (let [key, value] of m.backwards().backwards()) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     */\r\n    backwards() {\r\n        return new JsIterator(this.container, this.valuePolicy);\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    JsIterator: JsIterator,\r\n    JsReverseIterator: JsReverseIterator\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/public/js-iterators.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 178,
    "kind": "class",
    "name": "JsIterator",
    "memberof": "src/public/js-iterators.js",
    "static": true,
    "longname": "src/public/js-iterators.js~JsIterator",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/js-iterators.js",
    "importStyle": "{JsIterator}",
    "description": "ES6-style forward iterator.",
    "examples": [
      "let m = new TreeMap();\n...\nfor (let [key, value] of m) {\n  console.log(`key: ${key}, value: ${value}`);\n}\n// iterate values\nfor (let value of m.values()) {\n  console.log(`value: ${value}`);\n}"
    ],
    "lineNumber": 23,
    "interface": false
  },
  {
    "__docId__": 179,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/js-iterators.js~JsIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/js-iterators.js~JsIterator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "container",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "container",
    "memberof": "src/public/js-iterators.js~JsIterator",
    "static": false,
    "longname": "src/public/js-iterators.js~JsIterator#container",
    "access": "private",
    "description": "",
    "lineNumber": 32,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "name": "valuePolicy",
    "memberof": "src/public/js-iterators.js~JsIterator",
    "static": false,
    "longname": "src/public/js-iterators.js~JsIterator#valuePolicy",
    "access": "private",
    "description": "",
    "lineNumber": 37,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "node",
    "memberof": "src/public/js-iterators.js~JsIterator",
    "static": false,
    "longname": "src/public/js-iterators.js~JsIterator#node",
    "access": "private",
    "description": "",
    "lineNumber": 42,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "next",
    "memberof": "src/public/js-iterators.js~JsIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/js-iterators.js~JsIterator#next",
    "access": "public",
    "description": "As documented in ES6 iteration protocol. It can be used for manual iteration.\nIterators are documented here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators",
    "examples": [
      "let m = new TreeMap();\n...\nlet jsIt = m.entries();\nwhile (true) {\n  let res = it.next();\n  if (res.done) {\n    break;\n  }\n  console.log(`key: ${res.value[0]}, value: ${res.value[1]`});\n}"
    ],
    "lineNumber": 61,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/public/js-iterators.js~JsIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/js-iterators.js~JsIterator#[Symbol.iterator]",
    "access": "public",
    "description": "Support for ES6 for-of loops.",
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "backwards",
    "memberof": "src/public/js-iterators.js~JsIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/js-iterators.js~JsIterator#backwards",
    "access": "public",
    "description": "A reverse iterator for the same container.",
    "examples": [
      "let m = new TreeMap();\n...\n// iterate all key-value pairs in reverse order\nfor (let [key, value] of m.backwards()) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 187,
    "kind": "class",
    "name": "JsReverseIterator",
    "memberof": "src/public/js-iterators.js",
    "static": true,
    "longname": "src/public/js-iterators.js~JsReverseIterator",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/js-iterators.js",
    "importStyle": "{JsReverseIterator}",
    "description": "ES6-style backward iterator",
    "examples": [
      "let m = new TreeMap();\n...\n// iterate all key-value pairs in reverse order\nfor (let [key, value] of m.backwards()) {\n  console.log(`key: ${key}, value: ${value}`);\n}\n// iterate keys in reverse order\nfor (let key of m.keys().backwards()) {\n  console.log(`key: ${key}`);\n}"
    ],
    "lineNumber": 116,
    "interface": false
  },
  {
    "__docId__": 188,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/js-iterators.js~JsReverseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/js-iterators.js~JsReverseIterator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 120,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "container",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "container",
    "memberof": "src/public/js-iterators.js~JsReverseIterator",
    "static": false,
    "longname": "src/public/js-iterators.js~JsReverseIterator#container",
    "access": "private",
    "description": "",
    "lineNumber": 125,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "member",
    "name": "valuePolicy",
    "memberof": "src/public/js-iterators.js~JsReverseIterator",
    "static": false,
    "longname": "src/public/js-iterators.js~JsReverseIterator#valuePolicy",
    "access": "private",
    "description": "",
    "lineNumber": 130,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "node",
    "memberof": "src/public/js-iterators.js~JsReverseIterator",
    "static": false,
    "longname": "src/public/js-iterators.js~JsReverseIterator#node",
    "access": "private",
    "description": "",
    "lineNumber": 135,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "next",
    "memberof": "src/public/js-iterators.js~JsReverseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/js-iterators.js~JsReverseIterator#next",
    "access": "public",
    "description": "As documented in ES6 iteration protocol. It can be used for manual iteration.\nIterators are documented here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators",
    "examples": [
      "let m = new TreeMap();\n...\nlet jsIt = m.entries().backwards();\nwhile (true) {\n  let res = it.next();\n  if (res.done) {\n    break;\n  }\n  console.log(`key: ${res.value[0]}, value: ${res.value[1]`});\n}"
    ],
    "lineNumber": 154,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/public/js-iterators.js~JsReverseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/js-iterators.js~JsReverseIterator#[Symbol.iterator]",
    "access": "public",
    "description": "Support for ES6 for-of loops.",
    "lineNumber": 168,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "backwards",
    "memberof": "src/public/js-iterators.js~JsReverseIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/js-iterators.js~JsReverseIterator#backwards",
    "access": "public",
    "description": "A forward iterator for the same container",
    "examples": [
      "let m = new TreeMap();\n...\n// iterate all key-value pairs in direct order\nfor (let [key, value] of m.backwards().backwards()) {\n  console.log(`key: ${key}, value: ${value}`);"
    ],
    "lineNumber": 182,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 196,
    "kind": "file",
    "name": "src/public/main.js",
    "content": "/* This is an entry point to the library.\r\n   It collects all public classes and re-exports them */\r\n/**@private */\r\nconst {TreeMap} = require('./tree-map');\r\n/**@private */\r\nconst {TreeMultiMap} = require('./tree-multimap');\r\n/**@private */\r\nconst {TreeSet} = require('./tree-set');\r\n/**@private */\r\nconst {TreeMultiSet} = require('./tree-multiset');\r\n/**@private */\r\nconst {Iterator, ReverseIterator} = require('./iterators');\r\n/**@private */\r\nconst {JsIterator, JsReverseIterator} = require('./js-iterators');\r\n\r\nmodule.exports = {\r\n    Iterator: Iterator,\r\n    ReverseIterator: ReverseIterator,\r\n    JsIterator: JsIterator,\r\n    JsReverseIterator: JsReverseIterator,\r\n    TreeMap: TreeMap,\r\n    TreeMultiMap: TreeMultiMap,\r\n    TreeSet: TreeSet,\r\n    TreeMultiSet: TreeMultiSet,\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/public/main.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 197,
    "kind": "variable",
    "name": "TreeMap",
    "memberof": "src/public/main.js",
    "static": true,
    "longname": "src/public/main.js~TreeMap",
    "access": "private",
    "export": false,
    "importPath": "jstreemap/src/public/main.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "variable",
    "name": "TreeMultiMap",
    "memberof": "src/public/main.js",
    "static": true,
    "longname": "src/public/main.js~TreeMultiMap",
    "access": "private",
    "export": false,
    "importPath": "jstreemap/src/public/main.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "variable",
    "name": "TreeSet",
    "memberof": "src/public/main.js",
    "static": true,
    "longname": "src/public/main.js~TreeSet",
    "access": "private",
    "export": false,
    "importPath": "jstreemap/src/public/main.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "variable",
    "name": "TreeMultiSet",
    "memberof": "src/public/main.js",
    "static": true,
    "longname": "src/public/main.js~TreeMultiSet",
    "access": "private",
    "export": false,
    "importPath": "jstreemap/src/public/main.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "variable",
    "name": "Iterator",
    "memberof": "src/public/main.js",
    "static": true,
    "longname": "src/public/main.js~Iterator",
    "access": "private",
    "export": false,
    "importPath": "jstreemap/src/public/main.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "variable",
    "name": "JsIterator",
    "memberof": "src/public/main.js",
    "static": true,
    "longname": "src/public/main.js~JsIterator",
    "access": "private",
    "export": false,
    "importPath": "jstreemap/src/public/main.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "file",
    "name": "src/public/tree-map.js",
    "content": "/** An implementation of red-black tree */\r\nconst {Tree} = require('../internal/tree');\r\n/** Classes that regulate whether tree nodes hold keys only, or key-value pairs */\r\nconst {KeyValuePolicy} = require('../internal/policies');\r\n/** Node for a red-black tree */\r\nconst {TreeNode} = require('../internal/tree-node');\r\n\r\n/**\r\n * TreeMap is an associative container that stores elements formed\r\n * by a combination of a key value and a mapped value, following a specific order.\r\n *\r\n * In a TreeMap, the key values are generally used to sort and uniquely identify\r\n * the elements, while the mapped values store the content associated to this key.\r\n * The types of key and mapped value may differ.\r\n *\r\n * ## Container properties\r\n * * **Associative** - Elements in associative containers are referenced by their key\r\n * and not by their absolute position in the container.\r\n * * **Ordered** - The elements in the container follow a strict order at all times.\r\n * All inserted elements are given a position in this order.\r\n * * **Map** - Each element associates a key to a mapped value. Keys are meant\r\n * to identify the elements whose main content is the mapped value.\r\n * * **Unique keys** - No two elements in the container can have equivalent keys.\r\n *\r\n * @example\r\n * let map = new TreeMap();\r\n * // add few values\r\n * map.set(1, 'a');\r\n * map.set(2, 'b');\r\n * // find a value by key\r\n * let v = map.get(1); // << 'a'\r\n * // print all key-value pairs\r\n * for (let [key, value] of map) {\r\n *   console.log(`key: ${key}, value: ${value}`);\r\n * }\r\n */\r\nclass TreeMap {\r\n    /*======================================================\r\n     * Methods of ES6 Map\r\n     *======================================================*/\r\n\r\n    /**\r\n     * Creates an empty, or a pre-initialized map.\r\n     * @param {*} [iterable] Another iterable object whose key-value pairs are added into the newly created map.\r\n     * @example\r\n     * // Create an empty map\r\n     * let map1 = new TreeMap();\r\n     * // Create and initialize map\r\n     * let map2 = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     */\r\n    constructor(iterable) {\r\n        /** Internal tree */\r\n        this.__t = new Tree();\r\n        this.__t.valuePolicy = new KeyValuePolicy();\r\n        if ((iterable !== undefined)\r\n            && (iterable !== null)) {\r\n            if (iterable[Symbol.iterator] !== undefined) {\r\n                // copy contents\r\n                for (let [k, v] of iterable) {\r\n                    this.set(k, v);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('TreeMap constructor accepts only iterable objects');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * String tag of this class\r\n     * @returns {String}\r\n     * @example\r\n     * Object.prototype.toString.call(new TreeMap()); // \"[object TreeMap]\"\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return 'TreeMap';\r\n    }\r\n\r\n    /**\r\n     * Allows to create programmatically an instance of the same class\r\n     * @returns constructor object for this class.\r\n     * @example\r\n     * let map = new TreeMap();\r\n     * let constrFunc = Object.getPrototypeOf(map).constructor[Symbol.species];\r\n     * let map2 = new constrFunc();\r\n     */\r\n    static get [Symbol.species]() {\r\n        return TreeMap;\r\n    }\r\n\r\n    /**\r\n     * Removes all key-value pairs.\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * map.clear();\r\n     * console.log(map.size); // 0\r\n     */\r\n    clear() {\r\n        this.__t.clear();\r\n    }\r\n\r\n    /**\r\n     * Removes key-value pair with the specified key if such entry exists. Does nothing otherwise.\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * map.delete(2);\r\n     * console.log(map.toString()); // {1:A,3:C}\r\n     */\r\n    delete(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            this.__t.erase(it.node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all key-value pairs in ascending order of the keys.\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let [key,value] of map.entries()) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n     */\r\n    entries() {\r\n        return this.__t.entries();\r\n    }\r\n\r\n    /**\r\n     * Iterates all key-value pairs using a callback in ascending order of the keys.\r\n     * Note that ES6 specifies the order of key value parameters in the callback differently from for-of loop.\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * map.forEach(function(value, key, container) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * });\r\n     */\r\n    forEach(callback) {\r\n        for (let [k, v] of this.__t) {\r\n            callback(v, k, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds value associated with the specified key. If specified key does not exist then undefined is returned.\r\n     * @returns {*}\r\n     * @param {*} key a value of any type that can be compared with a key\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let v = map.get(3); // 'C'\r\n     * * let v = map.get(4); // returns undefined\r\n     */\r\n    get(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            return it.value;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A boolean indicator whether map contains a key-value pair with the specified key\r\n     * @returns {Boolean}\r\n     * @param {*} key a value of any type that can be compared with a key\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let b = map.get(3); // true\r\n     */\r\n    has(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all keys in ascending order of the keys.\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * // iterate all keys\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let k of map.keys()) {\r\n     *   console.log(k); // 1, 2, 3\r\n     * }\r\n     * // iterate all keys in reverse order\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let k of map.keys().backward()) {\r\n     *   console.log(k); // 3, 2, 1\r\n     * }\r\n     */\r\n    keys() {\r\n        return this.__t.keys();\r\n    }\r\n\r\n    /**\r\n     * Adds or updates key-value pair to the map.\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @example\r\n     * let map = new TreeMap();\r\n     * map.set(1, 'A');\r\n     */\r\n    set(key, value) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        n.value = value;\r\n        this.__t.insertOrReplace(n);\r\n    }\r\n\r\n    /**\r\n     * Number of key-value pairs in the map.\r\n     * @returns {Number}\r\n     */\r\n    get size() {\r\n        return this.__t.size();\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all values in ascending order of the keys.\r\n     * @returns {JsITerator}\r\n     * @example\r\n     * // iterate all values\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let v of map.values()) {\r\n     *   console.log(v); // 'A', 'B', 'C'\r\n     * }\r\n     * // iterate all values in reverse order\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let v of map.values().backward()) {\r\n     *   console.log(v); // 'C', 'B', 'A'\r\n     * }\r\n     */\r\n    values() {\r\n        return this.__t.values();\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all key-value pairs in ascending order of the keys. The same as entries() method\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let [key,value] of map) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n     */\r\n    [Symbol.iterator]() {\r\n        return this.__t[Symbol.iterator]();\r\n    }\r\n\r\n    /*======================================================\r\n     * More methods\r\n     *======================================================*/\r\n    /**\r\n     * ES6 reverse iterator for all key-value pairs in descending order of the keys.\r\n     * @returns {JsReverseIterator}\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let [key,value] of map.backwards()) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n     */\r\n    backward() {\r\n        return this.__t.backward();\r\n    }\r\n\r\n    /**\r\n     * Sets custom comparison function if key values are not of primitive types.\r\n     * Callback is a 3-way comparison function accepts two key values (lhs, rhs). It is expected to return\r\n     *      +1 if the value of rhs is greater than lhs\r\n     *      -1 if the value of rhs is less than lhs\r\n     *       0 if values are the same\r\n     */\r\n    set compareFunc(func) {\r\n        this.clear();\r\n        this.__t.compare = func;\r\n    }\r\n\r\n    /*======================================================\r\n     * STL-like methods\r\n     *======================================================*/\r\n\r\n    /**\r\n     * Forward iterator to the first element\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ...\r\n     * for (let it = m.begin(); !it.equals(m.end()); it.next()) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n     * }\r\n     */\r\n    begin() {\r\n        return this.__t.begin();\r\n    }\r\n\r\n    /**\r\n     * Forward iterator to the element following the last element\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ...\r\n     * for (let it = m.begin(); !it.equals(m.end()); it.next()) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n     * }\r\n     */\r\n    end() {\r\n        return this.__t.end();\r\n    }\r\n\r\n    /**\r\n     * Finds an element with key equivalent to the specified one. If such key does not exist end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * ...\r\n     * let it = m.find(1);\r\n     * if (!it.equals(m.end())) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`); // 1, 'A'\r\n     * }\r\n     */\r\n    find(key) {\r\n        return this.__t.find(key);\r\n    }\r\n\r\n    /**\r\n     * Adds key-value pair if such key does not exist in the map\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * let res = m.insertUnique(1, 'A');\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.value}`); // prints A\r\n     * }\r\n     * res = m.insertUnique(1, 'B') // this step has no effect on the map\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.key}`); // not executed\r\n     * }\r\n     */\r\n    insertUnique(key, value) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        n.value = value;\r\n        return this.__t.insertUnique(n);\r\n    }\r\n\r\n    /**\r\n     * Adds key-value pair if such key does not exist in the map. Replaces value if such key exists\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * let res = m.insertOrReplace(1, 'A');\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.value}`); // prints A\r\n     * }\r\n     * res = m.insertOrReplace(1, 'B') // replaces value on the existing node\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.key}`); // prints B\r\n     * }\r\n     */\r\n    insertOrReplace(key, value) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        n.value = value;\r\n        return this.__t.insertOrReplace(n);\r\n    }\r\n\r\n    /**\r\n     * Removes key-value pair for the specified iterator.\r\n     * @param {Iterator} iterator\r\n     * @example\r\n     * let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let it = map.find(2);\r\n     * it.prev();\r\n     * map.erase(it); // removes a node with key 1\r\n     * console.log(map.toString()); // {2:B,3:C}\r\n     */\r\n    erase(iterator) {\r\n        this.__t.erase(iterator.node);\r\n    }\r\n\r\n    /**\r\n     * Iterator pointing to the first element that is not less than specified key. If no such element is found, see end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive\r\n     * let from = m.lowerBound(0);\r\n     * let to = m.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     *\r\n     * let m = new TreeMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\r\n     * let from = new ReverseIterator(m.upperBound(50));\r\n     * let to = new ReverseIterator(m.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    lowerBound(key) {\r\n        return this.__t.lowerBound(key);\r\n    }\r\n\r\n    /**\r\n     * Reverse iterator to the last element.\r\n     * @returns {ReverseIterator}\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ...\r\n     * for (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n     * }\r\n     */\r\n    rbegin() {\r\n        return this.__t.rbegin();\r\n    }\r\n\r\n    /**\r\n     * Reverse iterator pointing to before the first element.\r\n     * @returns {ReverseIterator}\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ...\r\n     * for (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n     * }\r\n     */\r\n    rend() {\r\n        return this.__t.rend();\r\n    }\r\n\r\n    /**\r\n     * Iterator pointing to the first element that is greater than key. If no such element is found end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive\r\n     * let from = m.lowerBound(0);\r\n     * let to = m.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     *\r\n     * let m = new TreeMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\r\n     * let from = new ReverseIterator(m.upperBound(50));\r\n     * let to = new ReverseIterator(m.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    upperBound(key) {\r\n        return this.__t.upperBound(key);\r\n    }\r\n\r\n    /**\r\n     * @returns first key/value pair of the container, or undefined if container is empty\r\n     * @example\r\n     * let m = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let first = m.first();\r\n     * if (first) {\r\n     *   let key = first[0];   // 1\r\n     *   let value = first[1]; // 'A'\r\n     * }\r\n     */\r\n    first() {\r\n        return this.__t.first();\r\n    }\r\n\r\n    /**\r\n     * @returns last key/value pair of the container, or undefined if container is empty\r\n     * @example\r\n     * let m = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let last = m.last();\r\n     * if (last) {\r\n     *   let key = last[0];   // 3\r\n     *   let value = last[1]; // 'C'\r\n     * }\r\n     */\r\n    last() {\r\n        return this.__t.last();\r\n    }\r\n\r\n    /**\r\n     * Serializes contents of the map in the form {key1:value1,key2:value2,...}\r\n     * @returns {String}\r\n     */\r\n    toString() {\r\n        return this.__t.toString();\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    TreeMap: TreeMap,\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/public/tree-map.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 204,
    "kind": "variable",
    "name": "Tree",
    "memberof": "src/public/tree-map.js",
    "static": true,
    "longname": "src/public/tree-map.js~Tree",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-map.js",
    "importStyle": null,
    "description": "An implementation of red-black tree",
    "lineNumber": 2,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 205,
    "kind": "variable",
    "name": "KeyValuePolicy",
    "memberof": "src/public/tree-map.js",
    "static": true,
    "longname": "src/public/tree-map.js~KeyValuePolicy",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-map.js",
    "importStyle": null,
    "description": "Classes that regulate whether tree nodes hold keys only, or key-value pairs",
    "lineNumber": 4,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 206,
    "kind": "variable",
    "name": "TreeNode",
    "memberof": "src/public/tree-map.js",
    "static": true,
    "longname": "src/public/tree-map.js~TreeNode",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-map.js",
    "importStyle": null,
    "description": "Node for a red-black tree",
    "lineNumber": 6,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 207,
    "kind": "class",
    "name": "TreeMap",
    "memberof": "src/public/tree-map.js",
    "static": true,
    "longname": "src/public/tree-map.js~TreeMap",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/tree-map.js",
    "importStyle": "{TreeMap}",
    "description": "TreeMap is an associative container that stores elements formed\nby a combination of a key value and a mapped value, following a specific order.\n\nIn a TreeMap, the key values are generally used to sort and uniquely identify\nthe elements, while the mapped values store the content associated to this key.\nThe types of key and mapped value may differ.\n\n## Container properties\n* **Associative** - Elements in associative containers are referenced by their key\nand not by their absolute position in the container.\n* **Ordered** - The elements in the container follow a strict order at all times.\nAll inserted elements are given a position in this order.\n* **Map** - Each element associates a key to a mapped value. Keys are meant\nto identify the elements whose main content is the mapped value.\n* **Unique keys** - No two elements in the container can have equivalent keys.",
    "examples": [
      "let map = new TreeMap();\n// add few values\nmap.set(1, 'a');\nmap.set(2, 'b');\n// find a value by key\nlet v = map.get(1); // << 'a'\n// print all key-value pairs\nfor (let [key, value] of map) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 37,
    "interface": false
  },
  {
    "__docId__": 208,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#constructor",
    "access": "public",
    "description": "Creates an empty, or a pre-initialized map.",
    "examples": [
      "// Create an empty map\nlet map1 = new TreeMap();\n// Create and initialize map\nlet map2 = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);"
    ],
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "iterable",
        "description": "Another iterable object whose key-value pairs are added into the newly created map."
      }
    ]
  },
  {
    "__docId__": 209,
    "kind": "member",
    "name": "__t",
    "memberof": "src/public/tree-map.js~TreeMap",
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#__t",
    "access": "private",
    "description": "Internal tree",
    "lineNumber": 53,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "get",
    "name": "[Symbol.toStringTag]",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#[Symbol.toStringTag]",
    "access": "public",
    "description": "String tag of this class",
    "examples": [
      "Object.prototype.toString.call(new TreeMap()); // \"[object TreeMap]\""
    ],
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "get",
    "name": "[Symbol.species]",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/public/tree-map.js~TreeMap.[Symbol.species]",
    "access": "public",
    "description": "Allows to create programmatically an instance of the same class",
    "examples": [
      "let map = new TreeMap();\nlet constrFunc = Object.getPrototypeOf(map).constructor[Symbol.species];\nlet map2 = new constrFunc();"
    ],
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "constructor object for this class."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "constructor object for this class."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "clear",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#clear",
    "access": "public",
    "description": "Removes all key-value pairs.",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nmap.clear();\nconsole.log(map.size); // 0"
    ],
    "lineNumber": 98,
    "params": [],
    "return": null
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "delete",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#delete",
    "access": "public",
    "description": "Removes key-value pair with the specified key if such entry exists. Does nothing otherwise.",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nmap.delete(2);\nconsole.log(map.toString()); // {1:A,3:C}"
    ],
    "lineNumber": 109,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "entries",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#entries",
    "access": "public",
    "description": "Forward ES6 iterator for all key-value pairs in ascending order of the keys.",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let [key,value] of map.entries()) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "forEach",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#forEach",
    "access": "public",
    "description": "Iterates all key-value pairs using a callback in ascending order of the keys.\nNote that ES6 specifies the order of key value parameters in the callback differently from for-of loop.",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nmap.forEach(function(value, key, container) {\n  console.log(`key: ${key}, value: ${value}`);\n});"
    ],
    "lineNumber": 138,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "get",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#get",
    "access": "public",
    "description": "Finds value associated with the specified key. If specified key does not exist then undefined is returned.",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet v = map.get(3); // 'C'\n* let v = map.get(4); // returns undefined"
    ],
    "lineNumber": 153,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "a value of any type that can be compared with a key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "has",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#has",
    "access": "public",
    "description": "A boolean indicator whether map contains a key-value pair with the specified key",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet b = map.get(3); // true"
    ],
    "lineNumber": 171,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "a value of any type that can be compared with a key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "keys",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#keys",
    "access": "public",
    "description": "Forward ES6 iterator for all keys in ascending order of the keys.",
    "examples": [
      "// iterate all keys\nlet map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let k of map.keys()) {\n  console.log(k); // 1, 2, 3\n}\n// iterate all keys in reverse order\nlet map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let k of map.keys().backward()) {\n  console.log(k); // 3, 2, 1\n}"
    ],
    "lineNumber": 196,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "set",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#set",
    "access": "public",
    "description": "Adds or updates key-value pair to the map.",
    "examples": [
      "let map = new TreeMap();\nmap.set(1, 'A');"
    ],
    "lineNumber": 208,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 220,
    "kind": "get",
    "name": "size",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#size",
    "access": "public",
    "description": "Number of key-value pairs in the map.",
    "lineNumber": 219,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "values",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#values",
    "access": "public",
    "description": "Forward ES6 iterator for all values in ascending order of the keys.",
    "examples": [
      "// iterate all values\nlet map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let v of map.values()) {\n  console.log(v); // 'A', 'B', 'C'\n}\n// iterate all values in reverse order\nlet map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let v of map.values().backward()) {\n  console.log(v); // 'C', 'B', 'A'\n}"
    ],
    "lineNumber": 238,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsITerator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsITerator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#[Symbol.iterator]",
    "access": "public",
    "description": "Forward ES6 iterator for all key-value pairs in ascending order of the keys. The same as entries() method",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let [key,value] of map) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 251,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "backward",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#backward",
    "access": "public",
    "description": "ES6 reverse iterator for all key-value pairs in descending order of the keys.",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let [key,value] of map.backwards()) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 267,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 224,
    "kind": "set",
    "name": "compareFunc",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#compareFunc",
    "access": "public",
    "description": "Sets custom comparison function if key values are not of primitive types.\nCallback is a 3-way comparison function accepts two key values (lhs, rhs). It is expected to return\n     +1 if the value of rhs is greater than lhs\n     -1 if the value of rhs is less than lhs\n      0 if values are the same",
    "lineNumber": 278
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "begin",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#begin",
    "access": "public",
    "description": "Forward iterator to the first element",
    "examples": [
      "let m = new TreeMap();\n...\nfor (let it = m.begin(); !it.equals(m.end()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 297,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "end",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#end",
    "access": "public",
    "description": "Forward iterator to the element following the last element",
    "examples": [
      "let m = new TreeMap();\n...\nfor (let it = m.begin(); !it.equals(m.end()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 311,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "find",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#find",
    "access": "public",
    "description": "Finds an element with key equivalent to the specified one. If such key does not exist end() iterator is returned.",
    "examples": [
      "let m = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\n...\nlet it = m.find(1);\nif (!it.equals(m.end())) {\n  console.log(`key: ${it.key}, value: ${it.value}`); // 1, 'A'\n}"
    ],
    "lineNumber": 327,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "insertUnique",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#insertUnique",
    "access": "public",
    "description": "Adds key-value pair if such key does not exist in the map",
    "examples": [
      "let m = new TreeMap();\nlet res = m.insertUnique(1, 'A');\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.value}`); // prints A\n}\nres = m.insertUnique(1, 'B') // this step has no effect on the map\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.key}`); // not executed\n}"
    ],
    "lineNumber": 347,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "insertOrReplace",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#insertOrReplace",
    "access": "public",
    "description": "Adds key-value pair if such key does not exist in the map. Replaces value if such key exists",
    "examples": [
      "let m = new TreeMap();\nlet res = m.insertOrReplace(1, 'A');\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.value}`); // prints A\n}\nres = m.insertOrReplace(1, 'B') // replaces value on the existing node\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.key}`); // prints B\n}"
    ],
    "lineNumber": 370,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "erase",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#erase",
    "access": "public",
    "description": "Removes key-value pair for the specified iterator.",
    "examples": [
      "let map = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet it = map.find(2);\nit.prev();\nmap.erase(it); // removes a node with key 1\nconsole.log(map.toString()); // {2:B,3:C}"
    ],
    "lineNumber": 387,
    "params": [
      {
        "nullable": null,
        "types": [
          "Iterator"
        ],
        "spread": false,
        "optional": false,
        "name": "iterator",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "lowerBound",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#lowerBound",
    "access": "public",
    "description": "Iterator pointing to the first element that is not less than specified key. If no such element is found, see end() iterator is returned.",
    "examples": [
      "let m = new TreeMap();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive\nlet from = m.lowerBound(0);\nlet to = m.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}\n\nlet m = new TreeMap();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\nlet from = new ReverseIterator(m.upperBound(50));\nlet to = new ReverseIterator(m.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 418,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "rbegin",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#rbegin",
    "access": "public",
    "description": "Reverse iterator to the last element.",
    "examples": [
      "let m = new TreeMap();\n...\nfor (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 432,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "rend",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#rend",
    "access": "public",
    "description": "Reverse iterator pointing to before the first element.",
    "examples": [
      "let m = new TreeMap();\n...\nfor (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 446,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "upperBound",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#upperBound",
    "access": "public",
    "description": "Iterator pointing to the first element that is greater than key. If no such element is found end() iterator is returned.",
    "examples": [
      "let m = new TreeMap();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive\nlet from = m.lowerBound(0);\nlet to = m.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}\n\nlet m = new TreeMap();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\nlet from = new ReverseIterator(m.upperBound(50));\nlet to = new ReverseIterator(m.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 477,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "first",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#first",
    "access": "public",
    "description": "",
    "examples": [
      "let m = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet first = m.first();\nif (first) {\n  let key = first[0];   // 1\n  let value = first[1]; // 'A'\n}"
    ],
    "lineNumber": 491,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "first key/value pair of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "first key/value pair of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "last",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#last",
    "access": "public",
    "description": "",
    "examples": [
      "let m = new TreeMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet last = m.last();\nif (last) {\n  let key = last[0];   // 3\n  let value = last[1]; // 'C'\n}"
    ],
    "lineNumber": 505,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "last key/value pair of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "last key/value pair of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "toString",
    "memberof": "src/public/tree-map.js~TreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-map.js~TreeMap#toString",
    "access": "public",
    "description": "Serializes contents of the map in the form {key1:value1,key2:value2,...}",
    "lineNumber": 513,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 238,
    "kind": "file",
    "name": "src/public/tree-multimap.js",
    "content": "/** An implementation of red-black tree */\r\nconst {Tree} = require('../internal/tree');\r\n/** Classes that regulate whether tree nodes hold keys only, or key-value pairs */\r\nconst {KeyValuePolicy} = require('../internal/policies');\r\n/** Node for a red-black tree */\r\nconst {TreeNode} = require('../internal/tree-node');\r\n\r\n/**\r\n * TreeMultiMap is an associative container that stores elements formed by\r\n * a combination of a key value and a mapped value, following a specific order,\r\n * and where multiple elements can have equivalent keys.\r\n *\r\n * In a TreeMultiMap, the key values are generally used to sort and uniquely\r\n * identify the elements, while the mapped values store the content\r\n * associated to this key. The types of key and mapped value may differ.\r\n *\r\n * ## Container properties\r\n * * **Associative** - Elements in associative containers are referenced\r\n * by their key and not by their absolute position in the container.\r\n * * **Ordered** - The elements in the container follow a strict order\r\n * at all times. All inserted elements are given a position in this order.\r\n * * **Map** - Each element associates a key to a mapped value. Keys are meant\r\n * to identify the elements whose main content is the mapped value.\r\n * * **Multiple equivalent keys** - Multiple elements in the container\r\n * can have equivalent keys.\r\n *\r\n * @example\r\n * let map = new TreeMultiMap();\r\n * // add few values\r\n * map.set(1, 'a');\r\n * map.set(2, 'b');\r\n * map.set(2, 'c');\r\n * // find a value by key\r\n * let v = map.get(1); // << 'a'\r\n * find all values for a given key\r\n * // print all key-value pairs\r\n * let from = map.lowerBound(2);\r\n * let to = map.upperBound(2);\r\n * let it = from;\r\n * while (!it.equals(to)) {\r\n *   console.log(it.key);\r\n *   it.next();\r\n * }\r\n */\r\nclass TreeMultiMap {\r\n    /*======================================================\r\n     * Methods of ES6 Map\r\n     *======================================================*/\r\n\r\n    /**\r\n     * Creates an empty, or a pre-initialized map.\r\n     * @param {*} [iterable] Another iterable object whose key-value pairs are added into the newly created map.\r\n     * @example\r\n     * // Create an empty map\r\n     * let map1 = new TreeMultiMap();\r\n     * // Create and initialize map\r\n     * let map2 = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     */\r\n    constructor(iterable) {\r\n        /** Internal tree */\r\n        this.__t = new Tree();\r\n        this.__t.valuePolicy = new KeyValuePolicy();\r\n        if ((iterable !== undefined)\r\n            && (iterable !== null)) {\r\n            if (iterable[Symbol.iterator] !== undefined) {\r\n                // copy contents\r\n                for (let [k, v] of iterable) {\r\n                    this.set(k, v);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('TreeMultiMap constructor accepts only iterable objects');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * String tag of this class\r\n     * @returns {String}\r\n     * @example\r\n     * Object.prototype.toString.call(new TreeMultiMap()); // \"[object TreeMultiMap]\"\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return 'TreeMultiMap';\r\n    }\r\n\r\n    /**\r\n     * Allows to create programmatically an instance of the same class\r\n     * @returns constructor object for this class.\r\n     * @example\r\n     * let map = new TreeMultiMap();\r\n     * let constrFunc = Object.getPrototypeOf(map).constructor[Symbol.species];\r\n     * let map2 = new constrFunc();\r\n     */\r\n    static get [Symbol.species]() {\r\n        return TreeMultiMap;\r\n    }\r\n\r\n    /**\r\n     * Removes all key-value pairs.\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * map.clear();\r\n     * console.log(map.size); // 0\r\n     */\r\n    clear() {\r\n        this.__t.clear();\r\n    }\r\n\r\n    /**\r\n     * Removes key-value pair with the specified key if such entry exists. Does nothing otherwise.\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * map.delete(2);\r\n     * console.log(map.toString()); // {1:A,3:C}\r\n     */\r\n    delete(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            this.__t.erase(it.node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all key-value pairs in ascending order of the keys.\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let [key,value] of map.entries()) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n     */\r\n    entries() {\r\n        return this.__t.entries();\r\n    }\r\n\r\n    /**\r\n     * Iterates all key-value pairs using a callback in ascending order of the keys.\r\n     * Note that ES6 specifies the order of key value parameters in the callback differently from for-of loop.\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * map.forEach(function(value, key, container) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * });\r\n     */\r\n    forEach(callback) {\r\n        for (let [k, v] of this.__t) {\r\n            callback(v, k, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds value associated with the specified key. If specified key does not exist then undefined is returned.\r\n     * @returns {*}\r\n     * @param {*} key a value of any type that can be compared with a key\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let v = map.get(3); // 'C'\r\n     * * let v = map.get(4); // returns undefined\r\n     */\r\n    get(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            return it.value;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A boolean indicator whether map contains a key-value pair with the specified key\r\n     * @returns {Boolean}\r\n     * @param {*} key a value of any type that can be compared with a key\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let b = map.get(3); // true\r\n     */\r\n    has(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all keys in ascending order of the keys.\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * // iterate all keys\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let k of map.keys()) {\r\n     *   console.log(k); // 1, 2, 3\r\n     * }\r\n     * // iterate all keys in reverse order\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let k of map.keys().backward()) {\r\n     *   console.log(k); // 3, 2, 1\r\n     * }\r\n     */\r\n    keys() {\r\n        return this.__t.keys();\r\n    }\r\n\r\n    /**\r\n     * Adds a key-value pair to the map. Multiple key-value pairs with the same key are allowed in TreeMultiMap.\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @example\r\n     * let map = new TreeMultiMap();\r\n     * map.set(1, 'A');\r\n     * map.set(1, 'B');\r\n     * map.set(2, 'C');\r\n     * for (let k of map.values()) {\r\n     *   console.log(k); // A, B, C\r\n     * }\r\n     */\r\n    set(key, value) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        n.value = value;\r\n        this.__t.insertMulti(n);\r\n    }\r\n\r\n    /**\r\n     * Number of key-value pairs in the map.\r\n     * @returns {Number}\r\n     */\r\n    get size() {\r\n        return this.__t.size();\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all values in ascending order of the keys.\r\n     * @returns {JsITerator}\r\n     * @example\r\n     * // iterate all values\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let v of map.values()) {\r\n     *   console.log(v); // 'A', 'B', 'C'\r\n     * }\r\n     * // iterate all values in reverse order\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let v of map.values().backward()) {\r\n     *   console.log(v); // 'C', 'B', 'A'\r\n     * }\r\n     */\r\n    values() {\r\n        return this.__t.values();\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all key-value pairs in ascending order of the keys. The same as entries() method\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let [key,value] of map) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n     */\r\n    [Symbol.iterator]() {\r\n        return this.__t[Symbol.iterator]();\r\n    }\r\n\r\n    /*======================================================\r\n     * More methods\r\n     *======================================================*/\r\n    /**\r\n     * ES6 reverse iterator for all key-value pairs in descending order of the keys.\r\n     * @returns {JsReverseIterator}\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * for (let [key,value] of map.backwards()) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n     */\r\n    backward() {\r\n        return this.__t.backward();\r\n    }\r\n\r\n    /**\r\n     * Sets custom comparison function if key values are not of primitive types.\r\n     * Callback is a 3-way comparison function accepts two key values (lhs, rhs). It is expected to return\r\n     *      +1 if the value of rhs is greater than lhs\r\n     *      -1 if the value of rhs is less than lhs\r\n     *       0 if values are the same\r\n     */\r\n    set compareFunc(func) {\r\n        this.clear();\r\n        this.__t.compare = func;\r\n    }\r\n\r\n    /*======================================================\r\n     * STL-like methods\r\n     *======================================================*/\r\n\r\n    /**\r\n     * Forward iterator to the first element\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * ...\r\n     * for (let it = m.begin(); !it.equals(m.end()); it.next()) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n     * }\r\n     */\r\n    begin() {\r\n        return this.__t.begin();\r\n    }\r\n\r\n    /**\r\n     * Forward iterator to the element following the last element\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * ...\r\n     * for (let it = m.begin(); !it.equals(m.end()); it.next()) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n     * }\r\n     */\r\n    end() {\r\n        return this.__t.end();\r\n    }\r\n\r\n    /**\r\n     * Finds an element with key equivalent to the specified one. If such key does not exist end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * ...\r\n     * let it = m.find(1);\r\n     * if (!it.equals(m.end())) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`); // 1, 'A'\r\n     * }\r\n     */\r\n    find(key) {\r\n        return this.__t.find(key);\r\n    }\r\n\r\n    /**\r\n     * Adds key-value pair if such key does not exist in the map\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * let res = m.insertUnique(1, 'A');\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.value}`); // prints A\r\n     * }\r\n     * res = m.insertUnique(1, 'B') // this step has no effect on the map\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.key}`); // not executed\r\n     * }\r\n     */\r\n    insertUnique(key, value) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        n.value = value;\r\n        return this.__t.insertUnique(n);\r\n    }\r\n\r\n    /**\r\n     * Adds key-value pair if such key does not exist in the map. Replaces value if such key exists\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * let res = m.insertOrReplace(1, 'A');\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.value}`); // prints A\r\n     * }\r\n     * res = m.insertOrReplace(1, 'B') // replaces value on the existing node\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.key}`); // prints B\r\n     * }\r\n     */\r\n    insertOrReplace(key, value) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        n.value = value;\r\n        return this.__t.insertOrReplace(n);\r\n    }\r\n\r\n    /**\r\n     * Adds key-value pair. If such key already exists in the map then adds another node with the same key and a new value.\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * let res = m.insertMulti(1, 'A');\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.value}`); // prints A\r\n     * }\r\n     * res = m.insertMulti(1, 'B') // adds a new node\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.value}`); // prints B\r\n     *   it.prev();\r\n     *   console.log(`Previously inserted ${res.iterator.value}`); // prints A\r\n     * }\r\n     */\r\n    insertMulti(key, value) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        n.value = value;\r\n        return this.__t.insertMulti(n);\r\n    }\r\n\r\n    /**\r\n     * Removes key-value pair for the specified iterator.\r\n     * @param {Iterator} iterator\r\n     * @example\r\n     * let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let it = map.find(2);\r\n     * it.prev();\r\n     * map.erase(it); // removes a node with key 1\r\n     * console.log(map.toString()); // {2:B,3:C}\r\n     */\r\n    erase(iterator) {\r\n        this.__t.erase(iterator.node);\r\n    }\r\n\r\n    /**\r\n     * Iterator pointing to the first element that is not less than specified key. If no such element is found, see end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive\r\n     * let from = m.lowerBound(0);\r\n     * let to = m.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     *\r\n     * let m = new TreeMultiMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\r\n     * let from = new ReverseIterator(m.upperBound(50));\r\n     * let to = new ReverseIterator(m.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    lowerBound(key) {\r\n        return this.__t.lowerBound(key);\r\n    }\r\n\r\n    /**\r\n     * Reverse iterator to the last element.\r\n     * @returns {ReverseIterator}\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * ...\r\n     * for (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n     * }\r\n     */\r\n    rbegin() {\r\n        return this.__t.rbegin();\r\n    }\r\n\r\n    /**\r\n     * Reverse iterator pointing to before the first element.\r\n     * @returns {ReverseIterator}\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * ...\r\n     * for (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\r\n     *   console.log(`key: ${it.key}, value: ${it.value}`);\r\n     * }\r\n     */\r\n    rend() {\r\n        return this.__t.rend();\r\n    }\r\n\r\n    /**\r\n     * Iterator pointing to the first element that is greater than key. If no such element is found end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let m = new TreeMultiMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive\r\n     * let from = m.lowerBound(0);\r\n     * let to = m.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     *\r\n     * let m = new TreeMultiMap();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\r\n     * let from = new ReverseIterator(m.upperBound(50));\r\n     * let to = new ReverseIterator(m.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    upperBound(key) {\r\n        return this.__t.upperBound(key);\r\n    }\r\n\r\n    /**\r\n     * @returns first key/value pair of the container, or undefined if container is empty\r\n     * @example\r\n     * let m = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let first = m.first();\r\n     * if (first) {\r\n     *   let key = first[0];   // 1\r\n     *   let value = first[1]; // 'A'\r\n     * }\r\n     */\r\n    first() {\r\n        return this.__t.first();\r\n    }\r\n\r\n    /**\r\n     * @returns last key/value pair of the container, or undefined if container is empty\r\n     * @example\r\n     * let m = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\r\n     * let last = m.last();\r\n     * if (last) {\r\n     *   let key = last[0];   // 3\r\n     *   let value = last[1]; // 'C'\r\n     * }\r\n     */\r\n    last() {\r\n        return this.__t.last();\r\n    }\r\n\r\n    /**\r\n     * Serializes contents of the map in the form {key1:value1,key2:value2,...}\r\n     * @returns {String}\r\n     */\r\n    toString() {\r\n        return this.__t.toString();\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    TreeMultiMap: TreeMultiMap,\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/public/tree-multimap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 239,
    "kind": "variable",
    "name": "Tree",
    "memberof": "src/public/tree-multimap.js",
    "static": true,
    "longname": "src/public/tree-multimap.js~Tree",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-multimap.js",
    "importStyle": null,
    "description": "An implementation of red-black tree",
    "lineNumber": 2,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 240,
    "kind": "variable",
    "name": "KeyValuePolicy",
    "memberof": "src/public/tree-multimap.js",
    "static": true,
    "longname": "src/public/tree-multimap.js~KeyValuePolicy",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-multimap.js",
    "importStyle": null,
    "description": "Classes that regulate whether tree nodes hold keys only, or key-value pairs",
    "lineNumber": 4,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 241,
    "kind": "variable",
    "name": "TreeNode",
    "memberof": "src/public/tree-multimap.js",
    "static": true,
    "longname": "src/public/tree-multimap.js~TreeNode",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-multimap.js",
    "importStyle": null,
    "description": "Node for a red-black tree",
    "lineNumber": 6,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 242,
    "kind": "class",
    "name": "TreeMultiMap",
    "memberof": "src/public/tree-multimap.js",
    "static": true,
    "longname": "src/public/tree-multimap.js~TreeMultiMap",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/tree-multimap.js",
    "importStyle": "{TreeMultiMap}",
    "description": "TreeMultiMap is an associative container that stores elements formed by\na combination of a key value and a mapped value, following a specific order,\nand where multiple elements can have equivalent keys.\n\nIn a TreeMultiMap, the key values are generally used to sort and uniquely\nidentify the elements, while the mapped values store the content\nassociated to this key. The types of key and mapped value may differ.\n\n## Container properties\n* **Associative** - Elements in associative containers are referenced\nby their key and not by their absolute position in the container.\n* **Ordered** - The elements in the container follow a strict order\nat all times. All inserted elements are given a position in this order.\n* **Map** - Each element associates a key to a mapped value. Keys are meant\nto identify the elements whose main content is the mapped value.\n* **Multiple equivalent keys** - Multiple elements in the container\ncan have equivalent keys.",
    "examples": [
      "let map = new TreeMultiMap();\n// add few values\nmap.set(1, 'a');\nmap.set(2, 'b');\nmap.set(2, 'c');\n// find a value by key\nlet v = map.get(1); // << 'a'\nfind all values for a given key\n// print all key-value pairs\nlet from = map.lowerBound(2);\nlet to = map.upperBound(2);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 45,
    "interface": false
  },
  {
    "__docId__": 243,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#constructor",
    "access": "public",
    "description": "Creates an empty, or a pre-initialized map.",
    "examples": [
      "// Create an empty map\nlet map1 = new TreeMultiMap();\n// Create and initialize map\nlet map2 = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);"
    ],
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "iterable",
        "description": "Another iterable object whose key-value pairs are added into the newly created map."
      }
    ]
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "__t",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#__t",
    "access": "private",
    "description": "Internal tree",
    "lineNumber": 61,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "get",
    "name": "[Symbol.toStringTag]",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#[Symbol.toStringTag]",
    "access": "public",
    "description": "String tag of this class",
    "examples": [
      "Object.prototype.toString.call(new TreeMultiMap()); // \"[object TreeMultiMap]\""
    ],
    "lineNumber": 83,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "get",
    "name": "[Symbol.species]",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/public/tree-multimap.js~TreeMultiMap.[Symbol.species]",
    "access": "public",
    "description": "Allows to create programmatically an instance of the same class",
    "examples": [
      "let map = new TreeMultiMap();\nlet constrFunc = Object.getPrototypeOf(map).constructor[Symbol.species];\nlet map2 = new constrFunc();"
    ],
    "lineNumber": 95,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "constructor object for this class."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "constructor object for this class."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "clear",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#clear",
    "access": "public",
    "description": "Removes all key-value pairs.",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nmap.clear();\nconsole.log(map.size); // 0"
    ],
    "lineNumber": 106,
    "params": [],
    "return": null
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "delete",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#delete",
    "access": "public",
    "description": "Removes key-value pair with the specified key if such entry exists. Does nothing otherwise.",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nmap.delete(2);\nconsole.log(map.toString()); // {1:A,3:C}"
    ],
    "lineNumber": 117,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "entries",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#entries",
    "access": "public",
    "description": "Forward ES6 iterator for all key-value pairs in ascending order of the keys.",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let [key,value] of map.entries()) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 133,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "forEach",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#forEach",
    "access": "public",
    "description": "Iterates all key-value pairs using a callback in ascending order of the keys.\nNote that ES6 specifies the order of key value parameters in the callback differently from for-of loop.",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nmap.forEach(function(value, key, container) {\n  console.log(`key: ${key}, value: ${value}`);\n});"
    ],
    "lineNumber": 146,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "get",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#get",
    "access": "public",
    "description": "Finds value associated with the specified key. If specified key does not exist then undefined is returned.",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet v = map.get(3); // 'C'\n* let v = map.get(4); // returns undefined"
    ],
    "lineNumber": 161,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "a value of any type that can be compared with a key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "has",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#has",
    "access": "public",
    "description": "A boolean indicator whether map contains a key-value pair with the specified key",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet b = map.get(3); // true"
    ],
    "lineNumber": 179,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "a value of any type that can be compared with a key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "keys",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#keys",
    "access": "public",
    "description": "Forward ES6 iterator for all keys in ascending order of the keys.",
    "examples": [
      "// iterate all keys\nlet map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let k of map.keys()) {\n  console.log(k); // 1, 2, 3\n}\n// iterate all keys in reverse order\nlet map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let k of map.keys().backward()) {\n  console.log(k); // 3, 2, 1\n}"
    ],
    "lineNumber": 204,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "set",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#set",
    "access": "public",
    "description": "Adds a key-value pair to the map. Multiple key-value pairs with the same key are allowed in TreeMultiMap.",
    "examples": [
      "let map = new TreeMultiMap();\nmap.set(1, 'A');\nmap.set(1, 'B');\nmap.set(2, 'C');\nfor (let k of map.values()) {\n  console.log(k); // A, B, C\n}"
    ],
    "lineNumber": 221,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 255,
    "kind": "get",
    "name": "size",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#size",
    "access": "public",
    "description": "Number of key-value pairs in the map.",
    "lineNumber": 232,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "values",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#values",
    "access": "public",
    "description": "Forward ES6 iterator for all values in ascending order of the keys.",
    "examples": [
      "// iterate all values\nlet map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let v of map.values()) {\n  console.log(v); // 'A', 'B', 'C'\n}\n// iterate all values in reverse order\nlet map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let v of map.values().backward()) {\n  console.log(v); // 'C', 'B', 'A'\n}"
    ],
    "lineNumber": 251,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsITerator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsITerator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#[Symbol.iterator]",
    "access": "public",
    "description": "Forward ES6 iterator for all key-value pairs in ascending order of the keys. The same as entries() method",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let [key,value] of map) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 264,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "backward",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#backward",
    "access": "public",
    "description": "ES6 reverse iterator for all key-value pairs in descending order of the keys.",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nfor (let [key,value] of map.backwards()) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 280,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 259,
    "kind": "set",
    "name": "compareFunc",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#compareFunc",
    "access": "public",
    "description": "Sets custom comparison function if key values are not of primitive types.\nCallback is a 3-way comparison function accepts two key values (lhs, rhs). It is expected to return\n     +1 if the value of rhs is greater than lhs\n     -1 if the value of rhs is less than lhs\n      0 if values are the same",
    "lineNumber": 291
  },
  {
    "__docId__": 260,
    "kind": "method",
    "name": "begin",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#begin",
    "access": "public",
    "description": "Forward iterator to the first element",
    "examples": [
      "let m = new TreeMultiMap();\n...\nfor (let it = m.begin(); !it.equals(m.end()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 310,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 261,
    "kind": "method",
    "name": "end",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#end",
    "access": "public",
    "description": "Forward iterator to the element following the last element",
    "examples": [
      "let m = new TreeMultiMap();\n...\nfor (let it = m.begin(); !it.equals(m.end()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 324,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "find",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#find",
    "access": "public",
    "description": "Finds an element with key equivalent to the specified one. If such key does not exist end() iterator is returned.",
    "examples": [
      "let m = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\n...\nlet it = m.find(1);\nif (!it.equals(m.end())) {\n  console.log(`key: ${it.key}, value: ${it.value}`); // 1, 'A'\n}"
    ],
    "lineNumber": 340,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 263,
    "kind": "method",
    "name": "insertUnique",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#insertUnique",
    "access": "public",
    "description": "Adds key-value pair if such key does not exist in the map",
    "examples": [
      "let m = new TreeMultiMap();\nlet res = m.insertUnique(1, 'A');\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.value}`); // prints A\n}\nres = m.insertUnique(1, 'B') // this step has no effect on the map\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.key}`); // not executed\n}"
    ],
    "lineNumber": 360,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "insertOrReplace",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#insertOrReplace",
    "access": "public",
    "description": "Adds key-value pair if such key does not exist in the map. Replaces value if such key exists",
    "examples": [
      "let m = new TreeMultiMap();\nlet res = m.insertOrReplace(1, 'A');\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.value}`); // prints A\n}\nres = m.insertOrReplace(1, 'B') // replaces value on the existing node\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.key}`); // prints B\n}"
    ],
    "lineNumber": 383,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "insertMulti",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#insertMulti",
    "access": "public",
    "description": "Adds key-value pair. If such key already exists in the map then adds another node with the same key and a new value.",
    "examples": [
      "let m = new TreeMultiMap();\nlet res = m.insertMulti(1, 'A');\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.value}`); // prints A\n}\nres = m.insertMulti(1, 'B') // adds a new node\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.value}`); // prints B\n  it.prev();\n  console.log(`Previously inserted ${res.iterator.value}`); // prints A\n}"
    ],
    "lineNumber": 408,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "erase",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#erase",
    "access": "public",
    "description": "Removes key-value pair for the specified iterator.",
    "examples": [
      "let map = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet it = map.find(2);\nit.prev();\nmap.erase(it); // removes a node with key 1\nconsole.log(map.toString()); // {2:B,3:C}"
    ],
    "lineNumber": 425,
    "params": [
      {
        "nullable": null,
        "types": [
          "Iterator"
        ],
        "spread": false,
        "optional": false,
        "name": "iterator",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "lowerBound",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#lowerBound",
    "access": "public",
    "description": "Iterator pointing to the first element that is not less than specified key. If no such element is found, see end() iterator is returned.",
    "examples": [
      "let m = new TreeMultiMap();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive\nlet from = m.lowerBound(0);\nlet to = m.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}\n\nlet m = new TreeMultiMap();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\nlet from = new ReverseIterator(m.upperBound(50));\nlet to = new ReverseIterator(m.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 456,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 268,
    "kind": "method",
    "name": "rbegin",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#rbegin",
    "access": "public",
    "description": "Reverse iterator to the last element.",
    "examples": [
      "let m = new TreeMultiMap();\n...\nfor (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 470,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "rend",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#rend",
    "access": "public",
    "description": "Reverse iterator pointing to before the first element.",
    "examples": [
      "let m = new TreeMultiMap();\n...\nfor (let it = m.rbegin(); !it.equals(m.rend()); it.next()) {\n  console.log(`key: ${it.key}, value: ${it.value}`);\n}"
    ],
    "lineNumber": 484,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "upperBound",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#upperBound",
    "access": "public",
    "description": "Iterator pointing to the first element that is greater than key. If no such element is found end() iterator is returned.",
    "examples": [
      "let m = new TreeMultiMap();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive\nlet from = m.lowerBound(0);\nlet to = m.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}\n\nlet m = new TreeMultiMap();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\nlet from = new ReverseIterator(m.upperBound(50));\nlet to = new ReverseIterator(m.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 515,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "first",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#first",
    "access": "public",
    "description": "",
    "examples": [
      "let m = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet first = m.first();\nif (first) {\n  let key = first[0];   // 1\n  let value = first[1]; // 'A'\n}"
    ],
    "lineNumber": 529,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "first key/value pair of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "first key/value pair of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "last",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#last",
    "access": "public",
    "description": "",
    "examples": [
      "let m = new TreeMultiMap([[1, 'A'], [2, 'B'], [3, 'C']]);\nlet last = m.last();\nif (last) {\n  let key = last[0];   // 3\n  let value = last[1]; // 'C'\n}"
    ],
    "lineNumber": 543,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "last key/value pair of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "last key/value pair of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "toString",
    "memberof": "src/public/tree-multimap.js~TreeMultiMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multimap.js~TreeMultiMap#toString",
    "access": "public",
    "description": "Serializes contents of the map in the form {key1:value1,key2:value2,...}",
    "lineNumber": 551,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 274,
    "kind": "file",
    "name": "src/public/tree-multiset.js",
    "content": "/** An implementation of red-black tree */\r\nconst {Tree} = require('../internal/tree');\r\n/** Classes that regulate whether tree nodes hold keys only, or key-value pairs */\r\nconst {KeyOnlyPolicy} = require('../internal/policies');\r\n/** Node for a red-black tree */\r\nconst {TreeNode} = require('../internal/tree-node');\r\n\r\n/**\r\n * TreeMultiSet is a container that stores elements following a specific order,\r\n * and where multiple elements can have equivalent values.\r\n *\r\n * In a TreeMultiSet, the value of an element also identifies it\r\n * (the value is itself the key). The value of the elements in a multiset\r\n * cannot be modified once in the container (the elements are always immutable),\r\n * but they can be inserted or removed from the container.\r\n *\r\n * ## Container properties\r\n * * **Associative** - Elements in associative containers are referenced\r\n * by their key and not by their absolute position in the container.\r\n * * **Ordered** - The elements in the container follow a strict order\r\n * at all times. All inserted elements are given a position in this order.\r\n * * **Set** - The value of an element is also the key used to identify it.\r\n * * **Multiple equivalent keys** - Multiple elements in the container\r\n * can have equivalent keys.\r\n *\r\n * @example\r\n * let set = new TreeMultiSet();\r\n * // add few values\r\n * set.add(1);\r\n * set.add(2);\r\n * set.add(2);\r\n * // check whether key exists\r\n * let flag = set.has(1); // << true\r\n * // print all keys\r\n * for (let key of set) {\r\n *   console.log(`key: ${key}`); // 1, 2, 2\r\n * }\r\n */\r\nclass TreeMultiSet {\r\n    /*======================================================\r\n     * Methods of ES6 Set\r\n     *======================================================*/\r\n\r\n    /**\r\n     * Creates an empty, or a pre-initialized set.\r\n     * @param {*} [iterable] Another iterable object whose values are added into the newly created set.\r\n     * @example\r\n     * // Create an empty set\r\n     * let set = new TreeMultiSet();\r\n     * // Create and initialize set\r\n     * let set2 = new TreeMultiSet([1, 2, 3]);\r\n     */\r\n    constructor(iterable) {\r\n        /** Internal tree */\r\n        this.__t = new Tree();\r\n        this.__t.valuePolicy = new KeyOnlyPolicy();\r\n        if ((iterable !== undefined)\r\n            && (iterable !== null)) {\r\n            if (iterable[Symbol.iterator] !== undefined) {\r\n                // copy contents\r\n                for (let k of iterable) {\r\n                    this.add(k);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('TreeMultiSet constructor accepts only iterable objects');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * String tag of this class\r\n     * @returns {String}\r\n     * @example\r\n     * Object.prototype.toString.call(new TreeMultiSet()); // \"[object TreeMultiSet]\"\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return 'TreeMultiSet';\r\n    }\r\n\r\n    /**\r\n     * Allows to create programmatically an instance of the same class\r\n     * @returns constructor object for this class.\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * let constrFunc = Object.getPrototypeOf(set).constructor[Symbol.species];\r\n     * let set2 = new constrFunc();\r\n     */\r\n    static get [Symbol.species]() {\r\n        return TreeMultiSet;\r\n    }\r\n\r\n    /**\r\n     * Removes all key-value pairs.\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * set.clear();\r\n     * console.log(set.size); // 0\r\n     */\r\n    clear() {\r\n        this.__t.clear();\r\n    }\r\n\r\n    /**\r\n     * Removes key-value pair with the specified key if such entry exists. Does nothing otherwise.\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 2, 3]);\r\n     * set.delete(2);\r\n     * console.log(set.toString()); // {1,2,3}\r\n     * set.delete(2); / remove the second copy of the key\r\n     * console.log(set.toString()); // {1,3}\r\n     */\r\n    delete(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            this.__t.erase(it.node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all values in ascending order.\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * for (let key of set.entries()) {\r\n     *   console.log(`key: ${key}`);\r\n     * }\r\n     */\r\n    entries() {\r\n        return this.__t.entries();\r\n    }\r\n\r\n    /**\r\n     * Iterates all values using a callback in ascending order.\r\n     * Note that ES6 specifies the order of key parameters in the callback differently from for-of loop.\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * set.forEach(function(value, key, container) {\r\n     *   // value is the same as key\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * });\r\n     */\r\n    forEach(callback) {\r\n        for (let k of this.__t) {\r\n            callback(k, k, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A boolean indicator whether set contains the specified key.\r\n     * @returns {Boolean}\r\n     * @param {*} key a value of any type that can be compared with a key\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * let b = set.get(3); // true\r\n     * b = set.get(4); // false\r\n     */\r\n    has(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all keys in ascending order.\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * // iterate all keys\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * for (let k of set.keys()) {\r\n     *   console.log(k); // 1, 2, 3\r\n     * }\r\n     * // iterate all keys in reverse order\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * for (let k of set.keys().backward()) {\r\n     *   console.log(k); // 3, 2, 1\r\n     * }\r\n     */\r\n    keys() {\r\n        return this.__t.keys();\r\n    }\r\n\r\n    /**\r\n     * Adds a key to the set. If the key already exists then another entry with the same value is added.\r\n     * @param {*} key\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * set.add(1);\r\n     * set.add(1);\r\n     * set.add(2);\r\n     * // print all keys\r\n     * for (let key of set) {\r\n     *   console.log(`key: ${key}`); // 1, 1, 2\r\n     * }\r\n     */\r\n    add(key) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        this.__t.insertMulti(n);\r\n    }\r\n\r\n    /**\r\n     * Number of keys in the set.\r\n     * @returns {Number}\r\n     */\r\n    get size() {\r\n        return this.__t.size();\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all keys in ascending order. It is the same as keys() method\r\n     * @returns {JsITerator}\r\n     * @example\r\n     * // iterate all values\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * for (let v of set.values()) {\r\n     *   console.log(v); // '1', '2', '3'\r\n     * }\r\n     * // iterate all values in reverse order\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * for (let v of set.values().backward()) {\r\n     *   console.log(v); // '3', '2', '1'\r\n     * }\r\n     */\r\n    values() {\r\n        return this.__t.keys();\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all keys in ascending order. The same as entries() method\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * for (let key of set) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n     */\r\n    [Symbol.iterator]() {\r\n        return this.__t[Symbol.iterator]();\r\n    }\r\n\r\n    /*======================================================\r\n     * More methods\r\n     *======================================================*/\r\n    /**\r\n     * ES6 reverse iterator for all keys in descending order.\r\n     * @returns {JsReverseIterator}\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * for (let key of set.backwards()) {\r\n     *   console.log(`key: ${key}`);\r\n     * }\r\n     */\r\n    backward() {\r\n        return this.__t.backward();\r\n    }\r\n\r\n    /**\r\n     * Sets custom comparison function if key values are not of primitive types.\r\n     * Callback is a 3-way comparison function accepts two key values (lhs, rhs). It is expected to return\r\n     *      +1 if the value of rhs is greater than lhs\r\n     *      -1 if the value of rhs is less than lhs\r\n     *       0 if values are the same\r\n     */\r\n    set compareFunc(func) {\r\n        this.clear();\r\n        this.__t.compare = func;\r\n    }\r\n\r\n    /*======================================================\r\n     * STL-like methods\r\n     *======================================================*/\r\n\r\n    /**\r\n     * Forward iterator to the first element\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * ...\r\n     * for (let it = set.begin(); !it.equals(set.end()); it.next()) {\r\n     *   console.log(`key: ${it.key}`);\r\n     * }\r\n     */\r\n    begin() {\r\n        return this.__t.begin();\r\n    }\r\n\r\n    /**\r\n     * Forward iterator to the element following the last element\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * ...\r\n     * for (let it = set.begin(); !it.equals(set.end()); it.next()) {\r\n     *   console.log(`key: ${it.key}`);\r\n     * }\r\n     */\r\n    end() {\r\n        return this.__t.end();\r\n    }\r\n\r\n    /**\r\n     * Finds an element with key equivalent to the specified one. If such key does not exist end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * ...\r\n     * let it = set.find(1);\r\n     * if (!it.equals(set.end())) {\r\n     *   console.log(`Found key: ${it.key}`); // 1\r\n     * }\r\n     */\r\n    find(key) {\r\n        return this.__t.find(key);\r\n    }\r\n\r\n    /**\r\n     * Adds key if such key does not exist in the set.\r\n     * @param {*} key\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * set.insertUnique(1);\r\n     * set.insertUnique(1); // this step has no effect on the set\r\n     * let flag = set.has(1); // true\r\n     * let size = set.size; // 1\r\n     */\r\n    insertUnique(key) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        return this.__t.insertUnique(n);\r\n    }\r\n\r\n    /**\r\n     * Adds key if such key does not exist in the set. Same as insertUnique()\r\n     * @param {*} key\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * set.insertOrReplace(1);\r\n     * set.insertOrReplace(1); // this step has no effect on the set\r\n     * let flag = set.has(1); // true\r\n     * let size = set.size; // 1\r\n     */\r\n    insertOrReplace(key) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        return this.__t.insertOrReplace(n);\r\n    }\r\n\r\n    /**\r\n     * Adds key whether it exists or not in the set.\r\n     * @param {*} key\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * set.insertMulti(1);\r\n     * set.insertMulti(1); // this step has no effect on the map\r\n     * let flag = set.has(1); // true\r\n     * let size = set.size; // 2\r\n     */\r\n    insertMulti(key) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        return this.__t.insertMulti(n);\r\n    }\r\n\r\n    /**\r\n     * Removes value for the specified iterator.\r\n     * @param {Iterator} iterator\r\n     * @example\r\n     * let set = new TreeMultiSet([1,2,3]);\r\n     * let it = set.find(2);\r\n     * it.prev();\r\n     * set.erase(it); // removes a node with key 1\r\n     * console.log(set.toString()); // {2,3}\r\n     */\r\n    erase(iterator) {\r\n        this.__t.erase(iterator.node);\r\n    }\r\n\r\n    /**\r\n     * Iterator pointing to the first element that is not less than specified key. If no such element is found, see end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive\r\n     * let from = set.lowerBound(0);\r\n     * let to = set.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     *\r\n     * let set = new TreeMultiSet();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\r\n     * let from = new ReverseIterator(set.upperBound(50));\r\n     * let to = new ReverseIterator(set.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    lowerBound(key) {\r\n        return this.__t.lowerBound(key);\r\n    }\r\n\r\n    /**\r\n     * Reverse iterator to the last element.\r\n     * @returns {ReverseIterator}\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * ...\r\n     * for (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {\r\n     *   console.log(`key: ${it.key}`);\r\n     * }\r\n     */\r\n    rbegin() {\r\n        return this.__t.rbegin();\r\n    }\r\n\r\n    /**\r\n     * Reverse iterator pointing to before the first element.\r\n     * @returns {ReverseIterator}\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * ...\r\n     * for (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {\r\n     *   console.log(`key: ${it.key}`);\r\n     * }\r\n     */\r\n    rend() {\r\n        return this.__t.rend();\r\n    }\r\n\r\n    /**\r\n     * Iterator pointing to the first element that is greater than key. If no such element is found end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeMultiSet();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive\r\n     * let from = set.lowerBound(0);\r\n     * let to = set.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     *\r\n     * let set = new TreeMultiSet();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\r\n     * let from = new ReverseIterator(set.upperBound(50));\r\n     * let to = new ReverseIterator(set.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    upperBound(key) {\r\n        return this.__t.upperBound(key);\r\n    }\r\n\r\n    /**\r\n     * @returns first element of the container, or undefined if container is empty\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * let first = set.first(); // 1\r\n     */\r\n    first() {\r\n        return this.__t.first();\r\n    }\r\n\r\n    /**\r\n     * @returns last element of the container, or undefined if container is empty\r\n     * @example\r\n     * let set = new TreeMultiSet([1, 2, 3]);\r\n     * let last = set.last(); // 3\r\n     */\r\n    last() {\r\n        return this.__t.last();\r\n    }\r\n\r\n    /**\r\n     * Serializes contents of the set in the form {key1,key2,...}\r\n     * @returns {String}\r\n     */\r\n    toString() {\r\n        return this.__t.toString();\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    TreeMultiSet: TreeMultiSet,\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/public/tree-multiset.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 275,
    "kind": "variable",
    "name": "Tree",
    "memberof": "src/public/tree-multiset.js",
    "static": true,
    "longname": "src/public/tree-multiset.js~Tree",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-multiset.js",
    "importStyle": null,
    "description": "An implementation of red-black tree",
    "lineNumber": 2,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 276,
    "kind": "variable",
    "name": "KeyOnlyPolicy",
    "memberof": "src/public/tree-multiset.js",
    "static": true,
    "longname": "src/public/tree-multiset.js~KeyOnlyPolicy",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-multiset.js",
    "importStyle": null,
    "description": "Classes that regulate whether tree nodes hold keys only, or key-value pairs",
    "lineNumber": 4,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 277,
    "kind": "variable",
    "name": "TreeNode",
    "memberof": "src/public/tree-multiset.js",
    "static": true,
    "longname": "src/public/tree-multiset.js~TreeNode",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-multiset.js",
    "importStyle": null,
    "description": "Node for a red-black tree",
    "lineNumber": 6,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 278,
    "kind": "class",
    "name": "TreeMultiSet",
    "memberof": "src/public/tree-multiset.js",
    "static": true,
    "longname": "src/public/tree-multiset.js~TreeMultiSet",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/tree-multiset.js",
    "importStyle": "{TreeMultiSet}",
    "description": "TreeMultiSet is a container that stores elements following a specific order,\nand where multiple elements can have equivalent values.\n\nIn a TreeMultiSet, the value of an element also identifies it\n(the value is itself the key). The value of the elements in a multiset\ncannot be modified once in the container (the elements are always immutable),\nbut they can be inserted or removed from the container.\n\n## Container properties\n* **Associative** - Elements in associative containers are referenced\nby their key and not by their absolute position in the container.\n* **Ordered** - The elements in the container follow a strict order\nat all times. All inserted elements are given a position in this order.\n* **Set** - The value of an element is also the key used to identify it.\n* **Multiple equivalent keys** - Multiple elements in the container\ncan have equivalent keys.",
    "examples": [
      "let set = new TreeMultiSet();\n// add few values\nset.add(1);\nset.add(2);\nset.add(2);\n// check whether key exists\nlet flag = set.has(1); // << true\n// print all keys\nfor (let key of set) {\n  console.log(`key: ${key}`); // 1, 2, 2\n}"
    ],
    "lineNumber": 39,
    "interface": false
  },
  {
    "__docId__": 279,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#constructor",
    "access": "public",
    "description": "Creates an empty, or a pre-initialized set.",
    "examples": [
      "// Create an empty set\nlet set = new TreeMultiSet();\n// Create and initialize set\nlet set2 = new TreeMultiSet([1, 2, 3]);"
    ],
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "iterable",
        "description": "Another iterable object whose values are added into the newly created set."
      }
    ]
  },
  {
    "__docId__": 280,
    "kind": "member",
    "name": "__t",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#__t",
    "access": "private",
    "description": "Internal tree",
    "lineNumber": 55,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "get",
    "name": "[Symbol.toStringTag]",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#[Symbol.toStringTag]",
    "access": "public",
    "description": "String tag of this class",
    "examples": [
      "Object.prototype.toString.call(new TreeMultiSet()); // \"[object TreeMultiSet]\""
    ],
    "lineNumber": 77,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "get",
    "name": "[Symbol.species]",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/public/tree-multiset.js~TreeMultiSet.[Symbol.species]",
    "access": "public",
    "description": "Allows to create programmatically an instance of the same class",
    "examples": [
      "let set = new TreeMultiSet();\nlet constrFunc = Object.getPrototypeOf(set).constructor[Symbol.species];\nlet set2 = new constrFunc();"
    ],
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "constructor object for this class."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "constructor object for this class."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "clear",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#clear",
    "access": "public",
    "description": "Removes all key-value pairs.",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\nset.clear();\nconsole.log(set.size); // 0"
    ],
    "lineNumber": 100,
    "params": [],
    "return": null
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "delete",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#delete",
    "access": "public",
    "description": "Removes key-value pair with the specified key if such entry exists. Does nothing otherwise.",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 2, 3]);\nset.delete(2);\nconsole.log(set.toString()); // {1,2,3}\nset.delete(2); / remove the second copy of the key\nconsole.log(set.toString()); // {1,3}"
    ],
    "lineNumber": 113,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 285,
    "kind": "method",
    "name": "entries",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#entries",
    "access": "public",
    "description": "Forward ES6 iterator for all values in ascending order.",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\nfor (let key of set.entries()) {\n  console.log(`key: ${key}`);\n}"
    ],
    "lineNumber": 129,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "forEach",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#forEach",
    "access": "public",
    "description": "Iterates all values using a callback in ascending order.\nNote that ES6 specifies the order of key parameters in the callback differently from for-of loop.",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\nset.forEach(function(value, key, container) {\n  // value is the same as key\n  console.log(`key: ${key}, value: ${value}`);\n});"
    ],
    "lineNumber": 143,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "has",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#has",
    "access": "public",
    "description": "A boolean indicator whether set contains the specified key.",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\nlet b = set.get(3); // true\nb = set.get(4); // false"
    ],
    "lineNumber": 158,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "a value of any type that can be compared with a key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "keys",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#keys",
    "access": "public",
    "description": "Forward ES6 iterator for all keys in ascending order.",
    "examples": [
      "// iterate all keys\nlet set = new TreeMultiSet([1, 2, 3]);\nfor (let k of set.keys()) {\n  console.log(k); // 1, 2, 3\n}\n// iterate all keys in reverse order\nlet set = new TreeMultiSet([1, 2, 3]);\nfor (let k of set.keys().backward()) {\n  console.log(k); // 3, 2, 1\n}"
    ],
    "lineNumber": 183,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "add",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#add",
    "access": "public",
    "description": "Adds a key to the set. If the key already exists then another entry with the same value is added.",
    "examples": [
      "let set = new TreeMultiSet();\nset.add(1);\nset.add(1);\nset.add(2);\n// print all keys\nfor (let key of set) {\n  console.log(`key: ${key}`); // 1, 1, 2\n}"
    ],
    "lineNumber": 200,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 290,
    "kind": "get",
    "name": "size",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#size",
    "access": "public",
    "description": "Number of keys in the set.",
    "lineNumber": 210,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "values",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#values",
    "access": "public",
    "description": "Forward ES6 iterator for all keys in ascending order. It is the same as keys() method",
    "examples": [
      "// iterate all values\nlet set = new TreeMultiSet([1, 2, 3]);\nfor (let v of set.values()) {\n  console.log(v); // '1', '2', '3'\n}\n// iterate all values in reverse order\nlet set = new TreeMultiSet([1, 2, 3]);\nfor (let v of set.values().backward()) {\n  console.log(v); // '3', '2', '1'\n}"
    ],
    "lineNumber": 229,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsITerator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsITerator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#[Symbol.iterator]",
    "access": "public",
    "description": "Forward ES6 iterator for all keys in ascending order. The same as entries() method",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\nfor (let key of set) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 242,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "backward",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#backward",
    "access": "public",
    "description": "ES6 reverse iterator for all keys in descending order.",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\nfor (let key of set.backwards()) {\n  console.log(`key: ${key}`);\n}"
    ],
    "lineNumber": 258,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 294,
    "kind": "set",
    "name": "compareFunc",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#compareFunc",
    "access": "public",
    "description": "Sets custom comparison function if key values are not of primitive types.\nCallback is a 3-way comparison function accepts two key values (lhs, rhs). It is expected to return\n     +1 if the value of rhs is greater than lhs\n     -1 if the value of rhs is less than lhs\n      0 if values are the same",
    "lineNumber": 269
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "begin",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#begin",
    "access": "public",
    "description": "Forward iterator to the first element",
    "examples": [
      "let set = new TreeMultiSet();\n...\nfor (let it = set.begin(); !it.equals(set.end()); it.next()) {\n  console.log(`key: ${it.key}`);\n}"
    ],
    "lineNumber": 288,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "end",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#end",
    "access": "public",
    "description": "Forward iterator to the element following the last element",
    "examples": [
      "let set = new TreeMultiSet();\n...\nfor (let it = set.begin(); !it.equals(set.end()); it.next()) {\n  console.log(`key: ${it.key}`);\n}"
    ],
    "lineNumber": 302,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "find",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#find",
    "access": "public",
    "description": "Finds an element with key equivalent to the specified one. If such key does not exist end() iterator is returned.",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\n...\nlet it = set.find(1);\nif (!it.equals(set.end())) {\n  console.log(`Found key: ${it.key}`); // 1\n}"
    ],
    "lineNumber": 318,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "insertUnique",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#insertUnique",
    "access": "public",
    "description": "Adds key if such key does not exist in the set.",
    "examples": [
      "let set = new TreeMultiSet();\nset.insertUnique(1);\nset.insertUnique(1); // this step has no effect on the set\nlet flag = set.has(1); // true\nlet size = set.size; // 1"
    ],
    "lineNumber": 333,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "insertOrReplace",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#insertOrReplace",
    "access": "public",
    "description": "Adds key if such key does not exist in the set. Same as insertUnique()",
    "examples": [
      "let set = new TreeMultiSet();\nset.insertOrReplace(1);\nset.insertOrReplace(1); // this step has no effect on the set\nlet flag = set.has(1); // true\nlet size = set.size; // 1"
    ],
    "lineNumber": 350,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "insertMulti",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#insertMulti",
    "access": "public",
    "description": "Adds key whether it exists or not in the set.",
    "examples": [
      "let set = new TreeMultiSet();\nset.insertMulti(1);\nset.insertMulti(1); // this step has no effect on the map\nlet flag = set.has(1); // true\nlet size = set.size; // 2"
    ],
    "lineNumber": 367,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "erase",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#erase",
    "access": "public",
    "description": "Removes value for the specified iterator.",
    "examples": [
      "let set = new TreeMultiSet([1,2,3]);\nlet it = set.find(2);\nit.prev();\nset.erase(it); // removes a node with key 1\nconsole.log(set.toString()); // {2,3}"
    ],
    "lineNumber": 383,
    "params": [
      {
        "nullable": null,
        "types": [
          "Iterator"
        ],
        "spread": false,
        "optional": false,
        "name": "iterator",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "lowerBound",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#lowerBound",
    "access": "public",
    "description": "Iterator pointing to the first element that is not less than specified key. If no such element is found, see end() iterator is returned.",
    "examples": [
      "let set = new TreeMultiSet();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive\nlet from = set.lowerBound(0);\nlet to = set.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}\n\nlet set = new TreeMultiSet();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\nlet from = new ReverseIterator(set.upperBound(50));\nlet to = new ReverseIterator(set.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 414,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "rbegin",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#rbegin",
    "access": "public",
    "description": "Reverse iterator to the last element.",
    "examples": [
      "let set = new TreeMultiSet();\n...\nfor (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {\n  console.log(`key: ${it.key}`);\n}"
    ],
    "lineNumber": 428,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "rend",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#rend",
    "access": "public",
    "description": "Reverse iterator pointing to before the first element.",
    "examples": [
      "let set = new TreeMultiSet();\n...\nfor (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {\n  console.log(`key: ${it.key}`);\n}"
    ],
    "lineNumber": 442,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "upperBound",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#upperBound",
    "access": "public",
    "description": "Iterator pointing to the first element that is greater than key. If no such element is found end() iterator is returned.",
    "examples": [
      "let set = new TreeMultiSet();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive\nlet from = set.lowerBound(0);\nlet to = set.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}\n\nlet set = new TreeMultiSet();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\nlet from = new ReverseIterator(set.upperBound(50));\nlet to = new ReverseIterator(set.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 473,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "first",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#first",
    "access": "public",
    "description": "",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\nlet first = set.first(); // 1"
    ],
    "lineNumber": 483,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "first element of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "first element of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "last",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#last",
    "access": "public",
    "description": "",
    "examples": [
      "let set = new TreeMultiSet([1, 2, 3]);\nlet last = set.last(); // 3"
    ],
    "lineNumber": 493,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "last element of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "last element of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "toString",
    "memberof": "src/public/tree-multiset.js~TreeMultiSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-multiset.js~TreeMultiSet#toString",
    "access": "public",
    "description": "Serializes contents of the set in the form {key1,key2,...}",
    "lineNumber": 501,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 309,
    "kind": "file",
    "name": "src/public/tree-set.js",
    "content": "/** An implementation of red-black tree */\r\nconst {Tree} = require('../internal/tree');\r\n/** Classes that regulate whether tree nodes hold keys only, or key-value pairs */\r\nconst {KeyOnlyPolicy} = require('../internal/policies');\r\n/** Node for a red-black tree */\r\nconst {TreeNode} = require('../internal/tree-node');\r\n\r\n/**\r\n * TreeSet is a container that stores unique elements following a specific order.\r\n *\r\n * In a TreeSet, the value of an element also identifies it (the value is itself the key),\r\n * and each value must be unique. The value of the elements in a TreeSet cannot be modified\r\n * once in the container (the elements are immutable), but they can be inserted or removed\r\n * from the container.\r\n *\r\n * ## Container properties\r\n * * **Associative** - Elements in associative containers are referenced by their key and\r\n * not by their absolute position in the container.</li>\r\n * * **Ordered** - The elements in the container follow a strict order at all times.\r\n * All inserted elements are given a position in this order.</li>\r\n * * **Set** - The value of an element is also the key used to identify it.</li>\r\n * * **Unique keys** - No two elements in the container can have equivalent keys.</li>\r\n *\r\n *\r\n * @example\r\n * let set = new TreeSet();\r\n * // add few values\r\n * set.add(1);\r\n * set.add(2);\r\n * // check whether key exists\r\n * let flag = set.has(1); // << true\r\n * // print all keys\r\n * for (let key of set) {\r\n *   console.log(`key: ${key}`);\r\n * }\r\n */\r\nclass TreeSet {\r\n    /*======================================================\r\n     * Methods of ES6 Set\r\n     *======================================================*/\r\n\r\n    /**\r\n     * Creates an empty, or a pre-initialized set.\r\n     * @param {*} [iterable] Another iterable object whose values are added into the newly created set.\r\n     * @example\r\n     * // Create an empty set\r\n     * let set = new TreeSet();\r\n     * // Create and initialize set\r\n     * let set2 = new TreeSet([1, 2, 3]);\r\n     */\r\n    constructor(iterable) {\r\n        /** Internal tree */\r\n        this.__t = new Tree();\r\n        this.__t.valuePolicy = new KeyOnlyPolicy();\r\n        if ((iterable !== undefined)\r\n            && (iterable !== null)) {\r\n            if (iterable[Symbol.iterator] !== undefined) {\r\n                // copy contents\r\n                for (let k of iterable) {\r\n                    this.add(k);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('TreeSet constructor accepts only iterable objects');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * String tag of this class\r\n     * @returns {String}\r\n     * @example\r\n     * Object.prototype.toString.call(new TreeSet()); // \"[object TreeSet]\"\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return 'TreeSet';\r\n    }\r\n\r\n    /**\r\n     * Allows to create programmatically an instance of the same class\r\n     * @returns constructor object for this class.\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * let constrFunc = Object.getPrototypeOf(set).constructor[Symbol.species];\r\n     * let set2 = new constrFunc();\r\n     */\r\n    static get [Symbol.species]() {\r\n        return TreeSet;\r\n    }\r\n\r\n    /**\r\n     * Removes all key-value pairs.\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * set.clear();\r\n     * console.log(set.size); // 0\r\n     */\r\n    clear() {\r\n        this.__t.clear();\r\n    }\r\n\r\n    /**\r\n     * Removes key-value pair with the specified key if such entry exists. Does nothing otherwise.\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * set.delete(2);\r\n     * console.log(set.toString()); // {1,3}\r\n     */\r\n    delete(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            this.__t.erase(it.node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all values in ascending order.\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * for (let key of set.entries()) {\r\n     *   console.log(`key: ${key}`);\r\n     * }\r\n     */\r\n    entries() {\r\n        return this.__t.entries();\r\n    }\r\n\r\n    /**\r\n     * Iterates all values using a callback in ascending order.\r\n     * Note that ES6 specifies the order of key parameters in the callback differently from for-of loop.\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * set.forEach(function(value, key, container) {\r\n     *   // value is the same as key\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * });\r\n     */\r\n    forEach(callback) {\r\n        for (let k of this.__t) {\r\n            callback(k, k, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A boolean indicator whether set contains the specified key.\r\n     * @returns {Boolean}\r\n     * @param {*} key a value of any type that can be compared with a key\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * let b = set.get(3); // true\r\n     * b = set.get(4); // false\r\n     */\r\n    has(key) {\r\n        let it = this.__t.find(key);\r\n        if (!it.equals(this.__t.end())) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all keys in ascending order.\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * // iterate all keys\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * for (let k of set.keys()) {\r\n     *   console.log(k); // 1, 2, 3\r\n     * }\r\n     * // iterate all keys in reverse order\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * for (let k of set.keys().backward()) {\r\n     *   console.log(k); // 3, 2, 1\r\n     * }\r\n     */\r\n    keys() {\r\n        return this.__t.keys();\r\n    }\r\n\r\n    /**\r\n     * Adds a key to the set, unless the key already exists.\r\n     * @param {*} key\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * set.add(1);\r\n     */\r\n    add(key) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        this.__t.insertUnique(n);\r\n    }\r\n\r\n    /**\r\n     * Number of keys in the set.\r\n     * @returns {Number}\r\n     */\r\n    get size() {\r\n        return this.__t.size();\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all keys in ascending order. It is the same as keys() method\r\n     * @returns {JsITerator}\r\n     * @example\r\n     * // iterate all values\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * for (let v of set.values()) {\r\n     *   console.log(v); // '1', '2', '3'\r\n     * }\r\n     * // iterate all values in reverse order\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * for (let v of set.values().backward()) {\r\n     *   console.log(v); // '3', '2', '1'\r\n     * }\r\n     */\r\n    values() {\r\n        return this.__t.keys();\r\n    }\r\n\r\n    /**\r\n     * Forward ES6 iterator for all keys in ascending order. The same as entries() method\r\n     * @returns {JsIterator}\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * for (let key of set) {\r\n     *   console.log(`key: ${key}, value: ${value}`);\r\n     * }\r\n     */\r\n    [Symbol.iterator]() {\r\n        return this.__t[Symbol.iterator]();\r\n    }\r\n\r\n    /*======================================================\r\n     * More methods\r\n     *======================================================*/\r\n    /**\r\n     * ES6 reverse iterator for all keys in descending order.\r\n     * @returns {JsReverseIterator}\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * for (let key of set.backwards()) {\r\n     *   console.log(`key: ${key}`);\r\n     * }\r\n     */\r\n    backward() {\r\n        return this.__t.backward();\r\n    }\r\n\r\n    /**\r\n     * Sets custom comparison function if key values are not of primitive types.\r\n     * Callback is a 3-way comparison function accepts two key values (lhs, rhs). It is expected to return\r\n     *      +1 if the value of rhs is greater than lhs\r\n     *      -1 if the value of rhs is less than lhs\r\n     *       0 if values are the same\r\n     */\r\n    set compareFunc(func) {\r\n        this.clear();\r\n        this.__t.compare = func;\r\n    }\r\n\r\n    /*======================================================\r\n     * STL-like methods\r\n     *======================================================*/\r\n\r\n    /**\r\n     * Forward iterator to the first element\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * ...\r\n     * for (let it = set.begin(); !it.equals(set.end()); it.next()) {\r\n     *   console.log(`key: ${it.key}`);\r\n     * }\r\n     */\r\n    begin() {\r\n        return this.__t.begin();\r\n    }\r\n\r\n    /**\r\n     * Forward iterator to the element following the last element\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * ...\r\n     * for (let it = set.begin(); !it.equals(set.end()); it.next()) {\r\n     *   console.log(`key: ${it.key}`);\r\n     * }\r\n     */\r\n    end() {\r\n        return this.__t.end();\r\n    }\r\n\r\n    /**\r\n     * Finds an element with key equivalent to the specified one. If such key does not exist end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * ...\r\n     * let it = set.find(1);\r\n     * if (!it.equals(set.end())) {\r\n     *   console.log(`Found key: ${it.key}`); // 1\r\n     * }\r\n     */\r\n    find(key) {\r\n        return this.__t.find(key);\r\n    }\r\n\r\n    /**\r\n     * Adds a key if it doesn't exist\r\n     * @param {*} key\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * let res = set.insertUnique(1);\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.key}`); // prints 1\r\n     * }\r\n     * res = set.insertUnique(1); // this step has no effect on the set\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.key}`); // not executed\r\n     * }\r\n     */\r\n    insertUnique(key) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        return this.__t.insertUnique(n);\r\n    }\r\n\r\n    /**\r\n     * Adds key-value pair if such key does not exist in the map. Replaces value if such key exists\r\n     * @param {*} key\r\n     * @returns {InsertionResult} - indicates whether a node was added and provides iterator to it.\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * let res = set.insertOrReplace(1);\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.key}`); // prints 1\r\n     * }\r\n     * res = set.insertOrReplace(1) // returns iterator to the previously added node\r\n     * if (res.wasInserted) {\r\n     *   console.log(`Inserted ${res.iterator.key}`); // prints 1\r\n     * }\r\n     */\r\n    insertOrReplace(key) {\r\n        let n = new TreeNode();\r\n        n.key = key;\r\n        return this.__t.insertOrReplace(n);\r\n    }\r\n\r\n    /**\r\n     * Removes value for the specified iterator.\r\n     * @param {Iterator} iterator\r\n     * @example\r\n     * let set = new TreeSet([1,2,3]);\r\n     * let it = set.find(2);\r\n     * it.prev();\r\n     * set.erase(it); // removes a node with key 1\r\n     * console.log(set.toString()); // {2,3}\r\n     */\r\n    erase(iterator) {\r\n        this.__t.erase(iterator.node);\r\n    }\r\n\r\n    /**\r\n     * Iterator pointing to the first element that is not less than specified key. If no such element is found, see end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive\r\n     * let from = set.lowerBound(0);\r\n     * let to = set.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     *\r\n     * let set = new TreeSet();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\r\n     * let from = new ReverseIterator(set.upperBound(50));\r\n     * let to = new ReverseIterator(set.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    lowerBound(key) {\r\n        return this.__t.lowerBound(key);\r\n    }\r\n\r\n    /**\r\n     * Reverse iterator to the last element.\r\n     * @returns {ReverseIterator}\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * ...\r\n     * for (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {\r\n     *   console.log(`key: ${it.key}`);\r\n     * }\r\n     */\r\n    rbegin() {\r\n        return this.__t.rbegin();\r\n    }\r\n\r\n    /**\r\n     * Reverse iterator pointing to before the first element.\r\n     * @returns {ReverseIterator}\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * ...\r\n     * for (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {\r\n     *   console.log(`key: ${it.key}`);\r\n     * }\r\n     */\r\n    rend() {\r\n        return this.__t.rend();\r\n    }\r\n\r\n    /**\r\n     * Iterator pointing to the first element that is greater than key. If no such element is found end() iterator is returned.\r\n     * @param {*} key\r\n     * @returns {Iterator}\r\n     * @example\r\n     * let set = new TreeSet();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive\r\n     * let from = set.lowerBound(0);\r\n     * let to = set.upperBound(50);\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     *\r\n     * let set = new TreeSet();\r\n     * ... // add key-value pairs., using numbers as keys\r\n     * // iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\r\n     * let from = new ReverseIterator(set.upperBound(50));\r\n     * let to = new ReverseIterator(set.lowerBound(0));\r\n     * let it = from;\r\n     * while (!it.equals(to)) {\r\n     *   console.log(it.key);\r\n     *   it.next();\r\n     * }\r\n     */\r\n    upperBound(key) {\r\n        return this.__t.upperBound(key);\r\n    }\r\n\r\n    /**\r\n     * @returns first element of the container, or undefined if container is empty\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * let first = set.first(); // 1\r\n     */\r\n    first() {\r\n        return this.__t.first();\r\n    }\r\n\r\n    /**\r\n     * @returns last element of the container, or undefined if container is empty\r\n     * @example\r\n     * let set = new TreeSet([1, 2, 3]);\r\n     * let last = set.last(); // 3\r\n     */\r\n    last() {\r\n        return this.__t.last();\r\n    }\r\n\r\n    /**\r\n     * Serializes contents of the set in the form {key1,key2,...}\r\n     * @returns {String}\r\n     */\r\n    toString() {\r\n        return this.__t.toString();\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    TreeSet: TreeSet,\r\n};",
    "static": true,
    "longname": "D:/Personal/Projects/jstreemap/src/public/tree-set.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 310,
    "kind": "variable",
    "name": "Tree",
    "memberof": "src/public/tree-set.js",
    "static": true,
    "longname": "src/public/tree-set.js~Tree",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-set.js",
    "importStyle": null,
    "description": "An implementation of red-black tree",
    "lineNumber": 2,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 311,
    "kind": "variable",
    "name": "KeyOnlyPolicy",
    "memberof": "src/public/tree-set.js",
    "static": true,
    "longname": "src/public/tree-set.js~KeyOnlyPolicy",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-set.js",
    "importStyle": null,
    "description": "Classes that regulate whether tree nodes hold keys only, or key-value pairs",
    "lineNumber": 4,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 312,
    "kind": "variable",
    "name": "TreeNode",
    "memberof": "src/public/tree-set.js",
    "static": true,
    "longname": "src/public/tree-set.js~TreeNode",
    "access": "public",
    "export": false,
    "importPath": "jstreemap/src/public/tree-set.js",
    "importStyle": null,
    "description": "Node for a red-black tree",
    "lineNumber": 6,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 313,
    "kind": "class",
    "name": "TreeSet",
    "memberof": "src/public/tree-set.js",
    "static": true,
    "longname": "src/public/tree-set.js~TreeSet",
    "access": "public",
    "export": true,
    "importPath": "jstreemap/src/public/tree-set.js",
    "importStyle": "{TreeSet}",
    "description": "TreeSet is a container that stores unique elements following a specific order.\n\nIn a TreeSet, the value of an element also identifies it (the value is itself the key),\nand each value must be unique. The value of the elements in a TreeSet cannot be modified\nonce in the container (the elements are immutable), but they can be inserted or removed\nfrom the container.\n\n## Container properties\n* **Associative** - Elements in associative containers are referenced by their key and\nnot by their absolute position in the container.</li>\n* **Ordered** - The elements in the container follow a strict order at all times.\nAll inserted elements are given a position in this order.</li>\n* **Set** - The value of an element is also the key used to identify it.</li>\n* **Unique keys** - No two elements in the container can have equivalent keys.</li>",
    "examples": [
      "let set = new TreeSet();\n// add few values\nset.add(1);\nset.add(2);\n// check whether key exists\nlet flag = set.has(1); // << true\n// print all keys\nfor (let key of set) {\n  console.log(`key: ${key}`);\n}"
    ],
    "lineNumber": 37,
    "interface": false
  },
  {
    "__docId__": 314,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#constructor",
    "access": "public",
    "description": "Creates an empty, or a pre-initialized set.",
    "examples": [
      "// Create an empty set\nlet set = new TreeSet();\n// Create and initialize set\nlet set2 = new TreeSet([1, 2, 3]);"
    ],
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "iterable",
        "description": "Another iterable object whose values are added into the newly created set."
      }
    ]
  },
  {
    "__docId__": 315,
    "kind": "member",
    "name": "__t",
    "memberof": "src/public/tree-set.js~TreeSet",
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#__t",
    "access": "private",
    "description": "Internal tree",
    "lineNumber": 53,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "get",
    "name": "[Symbol.toStringTag]",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#[Symbol.toStringTag]",
    "access": "public",
    "description": "String tag of this class",
    "examples": [
      "Object.prototype.toString.call(new TreeSet()); // \"[object TreeSet]\""
    ],
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "get",
    "name": "[Symbol.species]",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/public/tree-set.js~TreeSet.[Symbol.species]",
    "access": "public",
    "description": "Allows to create programmatically an instance of the same class",
    "examples": [
      "let set = new TreeSet();\nlet constrFunc = Object.getPrototypeOf(set).constructor[Symbol.species];\nlet set2 = new constrFunc();"
    ],
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "constructor object for this class."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "constructor object for this class."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "clear",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#clear",
    "access": "public",
    "description": "Removes all key-value pairs.",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nset.clear();\nconsole.log(set.size); // 0"
    ],
    "lineNumber": 98,
    "params": [],
    "return": null
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "delete",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#delete",
    "access": "public",
    "description": "Removes key-value pair with the specified key if such entry exists. Does nothing otherwise.",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nset.delete(2);\nconsole.log(set.toString()); // {1,3}"
    ],
    "lineNumber": 109,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "entries",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#entries",
    "access": "public",
    "description": "Forward ES6 iterator for all values in ascending order.",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nfor (let key of set.entries()) {\n  console.log(`key: ${key}`);\n}"
    ],
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "forEach",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#forEach",
    "access": "public",
    "description": "Iterates all values using a callback in ascending order.\nNote that ES6 specifies the order of key parameters in the callback differently from for-of loop.",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nset.forEach(function(value, key, container) {\n  // value is the same as key\n  console.log(`key: ${key}, value: ${value}`);\n});"
    ],
    "lineNumber": 139,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "has",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#has",
    "access": "public",
    "description": "A boolean indicator whether set contains the specified key.",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nlet b = set.get(3); // true\nb = set.get(4); // false"
    ],
    "lineNumber": 154,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "a value of any type that can be compared with a key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 323,
    "kind": "method",
    "name": "keys",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#keys",
    "access": "public",
    "description": "Forward ES6 iterator for all keys in ascending order.",
    "examples": [
      "// iterate all keys\nlet set = new TreeSet([1, 2, 3]);\nfor (let k of set.keys()) {\n  console.log(k); // 1, 2, 3\n}\n// iterate all keys in reverse order\nlet set = new TreeSet([1, 2, 3]);\nfor (let k of set.keys().backward()) {\n  console.log(k); // 3, 2, 1\n}"
    ],
    "lineNumber": 179,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 324,
    "kind": "method",
    "name": "add",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#add",
    "access": "public",
    "description": "Adds a key to the set, unless the key already exists.",
    "examples": [
      "let set = new TreeSet();\nset.add(1);"
    ],
    "lineNumber": 190,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 325,
    "kind": "get",
    "name": "size",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#size",
    "access": "public",
    "description": "Number of keys in the set.",
    "lineNumber": 200,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "values",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#values",
    "access": "public",
    "description": "Forward ES6 iterator for all keys in ascending order. It is the same as keys() method",
    "examples": [
      "// iterate all values\nlet set = new TreeSet([1, 2, 3]);\nfor (let v of set.values()) {\n  console.log(v); // '1', '2', '3'\n}\n// iterate all values in reverse order\nlet set = new TreeSet([1, 2, 3]);\nfor (let v of set.values().backward()) {\n  console.log(v); // '3', '2', '1'\n}"
    ],
    "lineNumber": 219,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsITerator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsITerator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#[Symbol.iterator]",
    "access": "public",
    "description": "Forward ES6 iterator for all keys in ascending order. The same as entries() method",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nfor (let key of set) {\n  console.log(`key: ${key}, value: ${value}`);\n}"
    ],
    "lineNumber": 232,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "backward",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#backward",
    "access": "public",
    "description": "ES6 reverse iterator for all keys in descending order.",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nfor (let key of set.backwards()) {\n  console.log(`key: ${key}`);\n}"
    ],
    "lineNumber": 248,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JsReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JsReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 329,
    "kind": "set",
    "name": "compareFunc",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#compareFunc",
    "access": "public",
    "description": "Sets custom comparison function if key values are not of primitive types.\nCallback is a 3-way comparison function accepts two key values (lhs, rhs). It is expected to return\n     +1 if the value of rhs is greater than lhs\n     -1 if the value of rhs is less than lhs\n      0 if values are the same",
    "lineNumber": 259
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "begin",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#begin",
    "access": "public",
    "description": "Forward iterator to the first element",
    "examples": [
      "let set = new TreeSet();\n...\nfor (let it = set.begin(); !it.equals(set.end()); it.next()) {\n  console.log(`key: ${it.key}`);\n}"
    ],
    "lineNumber": 278,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "end",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#end",
    "access": "public",
    "description": "Forward iterator to the element following the last element",
    "examples": [
      "let set = new TreeSet();\n...\nfor (let it = set.begin(); !it.equals(set.end()); it.next()) {\n  console.log(`key: ${it.key}`);\n}"
    ],
    "lineNumber": 292,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "find",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#find",
    "access": "public",
    "description": "Finds an element with key equivalent to the specified one. If such key does not exist end() iterator is returned.",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\n...\nlet it = set.find(1);\nif (!it.equals(set.end())) {\n  console.log(`Found key: ${it.key}`); // 1\n}"
    ],
    "lineNumber": 308,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "insertUnique",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#insertUnique",
    "access": "public",
    "description": "Adds a key if it doesn't exist",
    "examples": [
      "let set = new TreeSet();\nlet res = set.insertUnique(1);\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.key}`); // prints 1\n}\nres = set.insertUnique(1); // this step has no effect on the set\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.key}`); // not executed\n}"
    ],
    "lineNumber": 327,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "insertOrReplace",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#insertOrReplace",
    "access": "public",
    "description": "Adds key-value pair if such key does not exist in the map. Replaces value if such key exists",
    "examples": [
      "let set = new TreeSet();\nlet res = set.insertOrReplace(1);\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.key}`); // prints 1\n}\nres = set.insertOrReplace(1) // returns iterator to the previously added node\nif (res.wasInserted) {\n  console.log(`Inserted ${res.iterator.key}`); // prints 1\n}"
    ],
    "lineNumber": 348,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{InsertionResult} - indicates whether a node was added and provides iterator to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "InsertionResult"
      ],
      "spread": false,
      "description": "indicates whether a node was added and provides iterator to it."
    }
  },
  {
    "__docId__": 335,
    "kind": "method",
    "name": "erase",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#erase",
    "access": "public",
    "description": "Removes value for the specified iterator.",
    "examples": [
      "let set = new TreeSet([1,2,3]);\nlet it = set.find(2);\nit.prev();\nset.erase(it); // removes a node with key 1\nconsole.log(set.toString()); // {2,3}"
    ],
    "lineNumber": 364,
    "params": [
      {
        "nullable": null,
        "types": [
          "Iterator"
        ],
        "spread": false,
        "optional": false,
        "name": "iterator",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 336,
    "kind": "method",
    "name": "lowerBound",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#lowerBound",
    "access": "public",
    "description": "Iterator pointing to the first element that is not less than specified key. If no such element is found, see end() iterator is returned.",
    "examples": [
      "let set = new TreeSet();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive\nlet from = set.lowerBound(0);\nlet to = set.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}\n\nlet set = new TreeSet();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\nlet from = new ReverseIterator(set.upperBound(50));\nlet to = new ReverseIterator(set.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 395,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 337,
    "kind": "method",
    "name": "rbegin",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#rbegin",
    "access": "public",
    "description": "Reverse iterator to the last element.",
    "examples": [
      "let set = new TreeSet();\n...\nfor (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {\n  console.log(`key: ${it.key}`);\n}"
    ],
    "lineNumber": 409,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 338,
    "kind": "method",
    "name": "rend",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#rend",
    "access": "public",
    "description": "Reverse iterator pointing to before the first element.",
    "examples": [
      "let set = new TreeSet();\n...\nfor (let it = set.rbegin(); !it.equals(set.rend()); it.next()) {\n  console.log(`key: ${it.key}`);\n}"
    ],
    "lineNumber": 423,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReverseIterator}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReverseIterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 339,
    "kind": "method",
    "name": "upperBound",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#upperBound",
    "access": "public",
    "description": "Iterator pointing to the first element that is greater than key. If no such element is found end() iterator is returned.",
    "examples": [
      "let set = new TreeSet();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive\nlet from = set.lowerBound(0);\nlet to = set.upperBound(50);\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}\n\nlet set = new TreeSet();\n... // add key-value pairs., using numbers as keys\n// iterate through all key-value pairs with keys between 0 and 50 inclusive in reverse order\nlet from = new ReverseIterator(set.upperBound(50));\nlet to = new ReverseIterator(set.lowerBound(0));\nlet it = from;\nwhile (!it.equals(to)) {\n  console.log(it.key);\n  it.next();\n}"
    ],
    "lineNumber": 454,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Iterator}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "first",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#first",
    "access": "public",
    "description": "",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nlet first = set.first(); // 1"
    ],
    "lineNumber": 464,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "first element of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "first element of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "last",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#last",
    "access": "public",
    "description": "",
    "examples": [
      "let set = new TreeSet([1, 2, 3]);\nlet last = set.last(); // 3"
    ],
    "lineNumber": 474,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "last element of the container, or undefined if container is empty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "last element of the container, or undefined if container is empty"
    },
    "params": []
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "toString",
    "memberof": "src/public/tree-set.js~TreeSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/public/tree-set.js~TreeSet#toString",
    "access": "public",
    "description": "Serializes contents of the set in the form {key1,key2,...}",
    "lineNumber": 482,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "kind": "index",
    "content": "# jstreemap\r\n[![ESDoc coverage](https://doc.esdoc.org/github.com/Kirusi/jstreemap/badge.svg)](https://doc.esdoc.org/github.com/Kirusi/jstreemap/)\r\n\r\nA JavaScript (ES6) library of tree-based associative containers. Library is UMD packaged and can be used in a Node environment as well as in a browser. The following containers are provided:\r\n* [**TreeSet**](https://kirusi.github.io/jstreemap/class/src/public/tree-set.js~TreeSet.html) - is a container that stores unique elements following a specific order. In a TreeSet, the value of an element also identifies it (the value is itself the key),and each value must be unique. The value of the elements in a TreeSet cannot be modified once in the container (the elements are immutable), but they can be inserted or removed from the container.\r\n* [**TreeMap**](https://kirusi.github.io/jstreemap/class/src/public/tree-map.js~TreeMap.html) - is an associative container that stores elements formed\r\nby a combination of a key value and a mapped value, following a specific order.\r\nIn a TreeMap, the key values are generally used to sort and uniquely identify\r\nthe elements, while the mapped values store the content associated to this key.\r\nThe types of key and mapped value may differ.\r\n* [**TreeMultiSet**](https://kirusi.github.io/jstreemap/class/src/public/tree-multiset.js~TreeMultiSet.html) - is a container that stores elements following a specific order, and where multiple elements can have equivalent values. In a TreeMultiSet, the value of an element also identifies it (the value is itself the key). The value of the elements in a multiset cannot be modified once in the container (the elements are always immutable), but they can be inserted or removed from the container.\r\n* [**TreeMultiMap**](https://kirusi.github.io/jstreemap/class/src/public/tree-multimap.js~TreeMultiMap.html) - is an associative container that stores elements formed by a combination of a key value and a mapped value, following a specific order, and where multiple elements can have equivalent keys. In a TreeMultiMap, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ.\r\n\r\nAll container implementations are using  red-black trees.\r\n\r\nThe library supports ES6 iteration protocol and STL-like iteration. In ES6 one can use a simple for-of loop to iterate through all items.\r\n```js\r\n// forward iteration\r\nfor(let [k,v] of map) {\r\n    console.log(`key: ${k}, value: ${v}`);\r\n}\r\n\r\n// reverse iteration\r\nfor(let [k,v] of map.backward) {\r\n    console.log(`key: ${k}, value: ${v}`);\r\n}\r\n```\r\n\r\nWith STL-like explicit iterators one can navigate through specific ranges in the container and update or erase some of the items during iteration.\r\n```js\r\n// find all elements with keys between 10 and 20 inclusive\r\nlet prevIter;\r\nfor (let it = map.lowerBound(10); !it.equals(map.upperBound(20); it.next()) {\r\n    if (prevIter !== undefined) {\r\n        // Check whether the previous iterator points to key 15\r\n        if (prevIter.key === 15) {\r\n            // we cannot erase current iterator. This would break iteration process\r\n            // But we can modify other items in the container.\r\n            map.erase(prevIter);\r\n        }\r\n    }\r\n    prevIter = new Iterator(it); // make a copy of current iterator\r\n}\r\n```\r\n\r\nDetailed library documentation is [here.](https://kirusi.github.io/jstreemap)\r\n\r\n## Installation\r\n\r\nUsing npm:\r\n```shell\r\n$ npm i --save jstreemap\r\n```\r\n\r\nIn Node.js:\r\n```js\r\n// Load library which is UMD packed.\r\nconst {TreeSet, TreeMap, TreeMultiSet, TreeMultiMap} = require('jstreemap');\r\n\r\n// Create and initialize map.\r\nlet map = new TreeMap([[2, 'B'], [1, 'A'], [3, 'C']]);\r\nmap.set(5, 'E');\r\nmap.set(4, 'D');\r\n// Iterate through all key-value pairs\r\n// Note that entries are stored in the ascending order of the keys,\r\n// not in the insertion order as in standard ES6 map\r\nfor(let [k,v] of map) {\r\n    console.log(`key: ${k}, value: ${v}`);\r\n}\r\n// Expected output:\r\n// key: 1, value: A\r\n// key: 2, value: B\r\n// key: 3, value: C\r\n// key: 4, value: D\r\n// key: 5, value: E\r\n...\r\n// Iterate elements in reverse order\r\nfor(let [k,v] of map.backward()) {\r\n    console.log(`key: ${k}, value: ${v}`);\r\n}\r\n...\r\n// find all elements with keys between 10 and 20 inclusive\r\nfor (let it = map.lowerBound(10); !it.equals(map.upperBound(20); it.next()) {\r\n    console.log(`key: ${it.key}, value: ${it.value}`);\r\n}\r\n```\r\n\r\nIn a browser:\r\n```html\r\n<!-- Load library which is UMD packed -->\r\n<script src=\"jstreemap.js\"></script>\r\n\r\n<script>\r\n// Classes TreeSet, TreeMap, TreeMultiSet, TreeMultiMap, Iterator, ReverseIterator,  JsIterator, JsReverseIterator are globally available\r\n\r\n// Create and initialize map.\r\nlet map = new TreeMap([[2, 'B'], [1, 'A'], [3, 'C']]);\r\n// Iterate through all key-value pairs\r\n// Note that entries are stored in the ascending order of the keys,\r\n// not in the insertion order as in standard ES6 map\r\nfor(let [k,v] of map) {\r\n    console.log(`key: ${k}, value: ${v}`);\r\n}\r\n// Expected output:\r\n// key: 1, value: A\r\n// key: 2, value: B\r\n// key: 3, value: C\r\n\r\n// Iterate elements in reverse order\r\nfor(let [k,v] of map.backward()) {\r\n    console.log(`key: ${k}, value: ${v}`);\r\n}\r\n\r\n// find all elements with keys between 10 and 20 inclusive\r\nfor (let it = map.lowerBound(10); !it.equals(map.upperBound(20); it.next()) {\r\n    console.log(`key: ${it.key}, value: ${it.value}`);\r\n}\r\n</script>\r\n```\r\n## Why jstreemap?\r\nOrdered associative containers are not provided by default with JavaScript. This library provides an efficient implementation where performance of insert, delete and search operations is O(log(n)).\r\n\r\nUnlike standard sets and maps in ES6, this library provides  ordered containers. Iteration through container contents will be done in sorted order without any additional performance overhead.\r\n\r\n[Container API](https://kirusi.github.io/jstreemap) implements features of default ES6 maps and sets as well as parts of STL (C++ library) interface.\r\n\r\nThe library showcases 100% test coverage and 100% documentation coverage.",
    "longname": "D:\\Personal\\Projects\\jstreemap\\README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"jstreemap\",\n  \"version\": \"1.19.1\",\n  \"description\": \"Library of associative containers; it implements TreeMap, TreeSet, TreeMultiMap and TreeMultiSet classes\",\n  \"main\": \"jstreemap.js\",\n  \"scripts\": {\n    \"esdoc\": \"esdoc -c ./esdoc.json\",\n    \"eslint-fix\": \"eslint --config=./config/eslint.config.json --fix src/**/*.js test/**/*.js gulpfile.js\",\n    \"eslint-watch\": \"esw --config=./config/eslint.config.json -w --fix src/**/*.js test/**/*.js gulpfile.js\",\n    \"test-watch\": \"mocha --reporter spec -w --recursive test/dev-tests/**/*.js\",\n    \"dev-test\": \"nyc --reporter=html --reporter=text --report-dir=./build/coverage --check-coverage --lines 100 --functions 100 --branches 100 mocha --reporter spec test/dev-tests/**/*.js\",\n    \"test\": \"nyc --reporter=html --reporter=text --report-dir=./build/coverage --check-coverage --lines 100 --functions 100 --branches 100 mocha --reporter spec test/dev-tests/**/*.js\",\n    \"prod-test\": \"nyc --reporter=html --reporter=text --report-dir=./build/postbuild-coverage mocha --reporter spec test/prod-tests/**/*.js\",\n    \"webpack\": \"webpack --config ./config/webpack.config.js\"\n  },\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/kirusi/jstreemap.git\"\n  },\n  \"keywords\": [\n    \"set\",\n    \"map\",\n    \"multimap\",\n    \"multiset\",\n    \"red\",\n    \"black\",\n    \"tree\",\n    \"stl\",\n    \"iterator\",\n    \"multimap\",\n    \"treemap\",\n    \"multiset\",\n    \"treeset\",\n    \"lower_bound\",\n    \"lowerBound\",\n    \"upper_bound\",\n    \"upperBound\",\n    \"ordered\",\n    \"container\",\n    \"find\",\n    \"insert\",\n    \"delete\",\n    \"erase\",\n    \"template\",\n    \"library\"\n  ],\n  \"author\": \"Kirusi Msafiri\",\n  \"license\": \"0BSD\",\n  \"bugs\": {\n    \"url\": \"https://github.com/kirusi/jstreemap/issues\"\n  },\n  \"homepage\": \"https://github.com/kirusi/jstreemap#readme\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"esdoc\": \"^1.0.4\",\n    \"esdoc-node\": \"^1.0.2\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^4.13.1\",\n    \"eslint-watch\": \"^3.1.3\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-util\": \"^3.0.8\",\n    \"mocha\": \"^4.0.1\",\n    \"nyc\": \"^11.4.1\",\n    \"should\": \"^13.1.3\",\n    \"webpack\": \"^3.10.0\",\n    \"yarn\": \"^1.3.2\"\n  }\n}\n",
    "longname": "D:\\Personal\\Projects\\jstreemap\\package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]